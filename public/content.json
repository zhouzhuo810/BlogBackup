{"pages":[{"title":"关于我","permalink":"http://zhouzhuo810.github.io/about/index.html","text":"Positiion : Android开发工程师 Email : admin@zhouzhuo810.me QQ : 244570672 Github: https://github.com/zhouzhuo810 简书: 去看看 个人网站: 去看看"},{"title":"","permalink":"http://zhouzhuo810.github.io/about/~$index.html","text":"\u0003998\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u00009\u00009\u00008\u0000\u0000\u0000\u0000\u0000\u0005\u0000D\u0000o\u0000t\u0000u\u0000m\u0000��*2\u0000\u0000\u0000\u0000��*2�]�2\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000p^�2\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000 _�2\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000�_�2\u0000\u0000\u0000\u0000\u0003\u0000\u0000\u0000�`�2\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000Xa�2\u0000\u0000\u0000\u0000"},{"title":"常用网址","permalink":"http://zhouzhuo810.github.io/links/index.html","text":"搜索引擎百度https://www.baidu.com JSON处理JSON格式化http://www.bejson.com/ JSON压缩转义http://www.bejson.com/zhuanyi/ 数据获取GUID获取https://www.guidgenerator.com/ 二维码生成https://cli.im/ 资源下载图标下载http://www.iconfont.cn/ UI设计图(动画等)http://www.ui.cn/ http://www.xueui.cn/ 三方平台腾讯buglyhttps://bugly.qq.com/v2 高德地图http://lbs.amap.com/ 支付宝开放平台https://open.alipay.com 微信开放平台https://open.weixin.qq.com/ 域名相关域名购买-godaddyhttps://sso.godaddy.com 域名解析-dnspodhttps://www.dnspod.cn Android主流市场百度http://app.baidu.com 小米http://dev.xiaomi.com/console/ vivohttp://dev.vivo.com.cn 360http://dev.360.cn/ 应用宝http://open.qq.com 华为http://developer.huawei.com/ oppohttp://open.oppomobile.com/newuser/login 魅族http://open.flyme.cn/?t=1489458048989 pp助手、豌豆荚http://open.uc.cn/ 联想乐商店http://open.lenovo.com/developer/ 乐视商店http://open.le.com/dev-web/ 搜狗开发者http://zhushou.sogou.com/open/ 应用汇http://dev.appchina.com/dev/index"},{"title":"工具下载","permalink":"http://zhouzhuo810.github.io/tools/index.html","text":"文本编辑工具Sublime Text 2百度云下载地址1密码：bfrv Android开发工具Android Studio 2.2.3官方下载地址 JDK 8 和 环境配置百度云下载地址1密码：y4km Andriod Studio 插件-ApiCreator(接口文档转API和实体类)Github下载地址 Andriod Studio 插件-StringKiller(layout字符串提取)Github下载地址 Andriod Studio 插件-Translator(实时翻译)百度云下载地址1密码：kedn Andriod Studio 插件-AndroidLocalizationer(国际化)百度云下载地址1密码：52dn SQLite浏览工具百度云下载地址1密码：6dgi TV远程安装APK-ApkInstaller百度云下载地址1密码：uf0q 美工PhotoShop CC 14.0百度云下载地址1密码：iahr JavaEE开发工具MySQL百度云下载地址1密码：5xby Tomcat百度云下载地址1密码：fupw MyEclipse百度云下载地址1密码：cka7 InteliJ IDEA 串口调试工具百度云下载地址1密码：3nwt 破解工具InteliJ IDEA 破解服务器百度云下载地址1密码：c8mq 网络调试工具百度云下载地址1密码：bhq8 服务器远程登录工具putty百度云下载地址1密码：7agk 游戏脚本小周荣耀助手-永久免费版百度云下载地址1密码：ifqa 快速下载PanDownload-百度云不限速下载百度云下载地址1密码：0orb"}],"posts":[{"title":"Android常用代码-微信QQ分享文件","permalink":"http://zhouzhuo810.github.io/2017/10/17/Android常用代码-微信QQ分享文件/","text":"不使用SDK实现QQ和微信文件分享。 QQ分享12345678910111213141516private void shareDbToQQ(File file) &#123; Intent share = new Intent(Intent.ACTION_SEND); ComponentName component = new ComponentName(&quot;com.tencent.mobileqq&quot;, &quot;com.tencent.mobileqq.activity.JumpActivity&quot;); share.setComponent(component); Uri uri = null; if (Build.VERSION.SDK_INT &gt; 23) &#123; uri = FileProvider.getUriForFile(getActivity(), BuildConfig.APPLICATION_ID + &quot;.provider&quot;, file); &#125; else &#123; uri = Uri.fromFile(file); &#125; share.putExtra(Intent.EXTRA_STREAM, uri); share.setType(&quot;*/*&quot;); startActivity(Intent.createChooser(share, &quot;发送&quot;));&#125; 微信分享123456789101112131415161718private void shareToWx(File file) &#123; Intent intent = new Intent(); ComponentName comp = new ComponentName(\"com.tencent.mm\", \"com.tencent.mm.ui.tools.ShareImgUI\"); intent.setComponent(comp); Uri uri = null; if (Build.VERSION.SDK_INT &gt; 23) &#123; uri = FileProvider.getUriForFile(getActivity(), BuildConfig.APPLICATION_ID + \".provider\", file); &#125; else &#123; uri = Uri.fromFile(file); &#125; intent.setAction(\"android.intent.action.SEND\"); intent.setType(\"file/*\"); intent.putExtra(Intent.EXTRA_TEXT, \"CE数据库\"); intent.putExtra(Intent.EXTRA_STREAM, uri); startActivity(intent);&#125;"},{"title":"Android常用代码-微信支付宝支付","permalink":"http://zhouzhuo810.github.io/2017/10/17/Android常用代码-微信支付宝支付/","text":"记录一下支付功能简单实现逻辑。 微信支付注册一个入口Activity123456&lt;!--weixin pay--&gt;&lt;activity android:name=&quot;.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot; /&gt;&lt;!--weixin pay--&gt; 可自定义界面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.keqiang.highcloud.wxapi; import android.content.Intent;import android.os.Bundle;import android.widget.TextView; import com.keqiang.highcloud.Constants;import com.keqiang.highcloud.R;import com.keqiang.highcloud.view.activity.BaseActivity;import com.keqiang.highcloud.view.activity.shop.ShopMyOrderActivity;import com.tencent.mm.opensdk.constants.ConstantsAPI;import com.tencent.mm.opensdk.modelbase.BaseReq;import com.tencent.mm.opensdk.modelbase.BaseResp;import com.tencent.mm.opensdk.openapi.IWXAPI;import com.tencent.mm.opensdk.openapi.IWXAPIEventHandler;import com.tencent.mm.opensdk.openapi.WXAPIFactory; public class WXPayEntryActivity extends BaseActivity implements IWXAPIEventHandler &#123; private static final String TAG = \"MicroMsg.SDKSample.WXPayEntryActivity\"; private IWXAPI api; private TextView tvResult; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); api = WXAPIFactory.createWXAPI(this, Constants.APP_ID); api.handleIntent(getIntent(), this);// finish(); &#125; @Override public int getLayoutId() &#123; return R.layout.pay_result; &#125; @Override public void initView() &#123; tvResult = (TextView) findViewById(R.id.tv_result); &#125; @Override public void initData() &#123; &#125; @Override public void initEvent() &#123; &#125; @Override public void saveState(Bundle bundle) &#123; &#125; @Override public void restoreState(Bundle bundle) &#123; &#125; @Override public boolean isDefaultBackClose() &#123; return false; &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); api.handleIntent(intent, this);// finish(); &#125; @Override public void onReq(BaseReq req) &#123; &#125; @Override public void onResp(BaseResp resp) &#123; if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123; if (resp.errCode == 0) &#123; tvResult.setText(\"微信支付完成！\"); Intent intent = new Intent(WXPayEntryActivity.this, ShopMyOrderActivity.class); startActWithIntent(intent); &#125; else &#123; tvResult.setText(resp.errStr); &#125; finish(); /* AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(R.string.app_tip); builder.setMessage(getString(R.string.pay_result_callback_msg, String.valueOf(resp.errCode))); builder.show();*/ &#125; &#125;&#125; 为保证支付前已将app注册到微信 注册一个广播 123456789&lt;!-- wx pay start--&gt;&lt;receiver android:name=\".other.receiver.AppRegister\" android:permission=\"com.tencent.mm.plugin.permission.SEND\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"com.tencent.mm.plugin.openapi.Intent.ACTION_REFRESH_WXAPP\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;!--wx pay end--&gt; 在Application中发送广播 1234/*注册APP到微信*/Intent intent = new Intent();intent.setAction(\"com.tencent.mm.plugin.openapi.Intent.ACTION_REFRESH_WXAPP\");sendBroadcast(intent); 支付宝支付网页登陆支付1234567891011121314&lt;!-- alipay sdk begin --&gt;&lt;activity android:name=\"com.alipay.sdk.app.H5PayActivity\" android:configChanges=\"orientation|keyboardHidden|navigation|screenSize\" android:exported=\"false\" android:screenOrientation=\"behind\" android:windowSoftInputMode=\"adjustResize|stateHidden\"/&gt;&lt;activity android:name=\"com.alipay.sdk.app.H5AuthActivity\" android:configChanges=\"orientation|keyboardHidden|navigation\" android:exported=\"false\" android:screenOrientation=\"behind\" android:windowSoftInputMode=\"adjustResize|stateHidden\"/&gt;&lt;!-- alipay sdk end --&gt; 支付界面Layout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/root\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;com.example.view.widget.ZzTitleBar android:id=\"@+id/title_bar\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/activity_title_height\" android:background=\"@color/colorMain\" app:leftImg=\"@drawable/iv_back\" app:leftText=\"@string/back_text\" app:showLeftLayout=\"true\" app:showRightLayout=\"false\" app:textColorAll=\"@color/color_white\" app:textSizeAll=\"@dimen/activity_title_text_size\" app:titleText=\"支付订单\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"88px\" android:background=\"#fff\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"支付剩余时间\" android:textColor=\"#666\" android:textSize=\"24px\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"4px\" android:gravity=\"center_horizontal\" android:orientation=\"horizontal\"&gt; &lt;TextView android:id=\"@+id/tv_minute_shi\" android:layout_width=\"30px\" android:layout_height=\"30px\" android:background=\"@drawable/zhifu_top_kuang\" android:gravity=\"center\" android:text=\"0\" android:textColor=\"#fff\" android:textSize=\"20px\" /&gt; &lt;TextView android:id=\"@+id/tv_minute_ge\" android:layout_width=\"30px\" android:layout_height=\"30px\" android:layout_marginLeft=\"10px\" android:background=\"@drawable/zhifu_top_kuang\" android:gravity=\"center\" android:text=\"0\" android:textColor=\"#fff\" android:textSize=\"20px\" /&gt; &lt;TextView android:layout_width=\"30px\" android:layout_height=\"30px\" android:layout_marginLeft=\"5px\" android:gravity=\"center\" android:text=\":\" android:textColor=\"#333\" android:textSize=\"20px\" /&gt; &lt;TextView android:id=\"@+id/tv_second_shi\" android:layout_width=\"30px\" android:layout_height=\"30px\" android:layout_marginLeft=\"5px\" android:background=\"@drawable/zhifu_top_kuang\" android:gravity=\"center\" android:text=\"0\" android:textColor=\"#fff\" android:textSize=\"20px\" /&gt; &lt;TextView android:id=\"@+id/tv_second_ge\" android:layout_width=\"30px\" android:layout_height=\"30px\" android:layout_marginLeft=\"10px\" android:background=\"@drawable/zhifu_top_kuang\" android:gravity=\"center\" android:text=\"0\" android:textColor=\"#fff\" android:textSize=\"20px\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"#f1f1f1\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"112px\" android:background=\"#fff\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;LinearLayout android:layout_width=\"260px\" android:layout_height=\"match_parent\" android:gravity=\"center_vertical\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_product_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"80px\" android:text=\"畅享管\" android:textColor=\"#333\" android:textSize=\"24px\" /&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"80px\" android:layout_marginTop=\"4px\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"数量：\" android:textColor=\"#999\" android:textSize=\"18px\" /&gt; &lt;TextView android:id=\"@+id/tv_number\" android:layout_width=\"100px\" android:layout_height=\"wrap_content\" android:background=\"@drawable/order_round_bg_shape\" android:gravity=\"center\" android:paddingBottom=\"2px\" android:paddingLeft=\"15px\" android:paddingRight=\"15px\" android:paddingTop=\"2px\" android:text=\"1\" android:textColor=\"#ff6631\" android:textSize=\"18px\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"80px\" android:layout_marginTop=\"4px\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"型号：\" android:textColor=\"#999\" android:textSize=\"18px\" /&gt; &lt;TextView android:id=\"@+id/tv_type\" android:layout_width=\"100px\" android:layout_height=\"wrap_content\" android:background=\"@drawable/order_round_bg_shape\" android:gravity=\"center\" android:paddingBottom=\"2px\" android:paddingLeft=\"15px\" android:paddingRight=\"15px\" android:paddingTop=\"2px\" android:text=\"\" android:textColor=\"#ff6631\" android:textSize=\"18px\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=\"1px\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"4px\" android:layout_marginLeft=\"20px\" android:layout_marginTop=\"4px\" android:background=\"#f1f1f1\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"40px\" android:gravity=\"bottom\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"¥\" android:textColor=\"#f74e37\" android:textSize=\"20px\" /&gt; &lt;TextView android:id=\"@+id/tv_count\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"\" android:textColor=\"#f74e37\" android:textSize=\"60px\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"30px\" android:background=\"#fff\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:id=\"@+id/ll_alipay\" android:layout_width=\"match_parent\" android:layout_height=\"120px\" android:background=\"@drawable/setting_item_bg_selector\" android:clickable=\"true\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:layout_width=\"60px\" android:layout_height=\"60px\" android:layout_marginLeft=\"34px\" android:src=\"@drawable/alipay_logo\" /&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"34px\" android:layout_weight=\"1\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"支付宝\" android:textColor=\"#333\" android:textSize=\"30px\" /&gt; &lt;ImageView android:layout_width=\"60px\" android:layout_height=\"26px\" android:layout_marginLeft=\"20px\" android:src=\"@drawable/pay_type_recomend\" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10px\" android:text=\"亿万用户的选择 , 更快更安全\" android:textColor=\"#999\" android:textSize=\"20px\" /&gt; &lt;/LinearLayout&gt; &lt;CheckBox android:id=\"@+id/cb_alipay\" android:layout_width=\"34px\" android:layout_height=\"34px\" android:layout_marginRight=\"30px\" android:background=\"@drawable/dingdan_btn_xuanzhe_selector\" android:button=\"@null\" android:checked=\"true\" android:clickable=\"false\" android:enabled=\"false\" /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"#f1f1f1\" /&gt; &lt;LinearLayout android:id=\"@+id/ll_wxpay\" android:layout_width=\"match_parent\" android:layout_height=\"120px\" android:background=\"@drawable/setting_item_bg_selector\" android:clickable=\"true\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:layout_width=\"60px\" android:layout_height=\"60px\" android:layout_marginLeft=\"34px\" android:src=\"@drawable/weixin_logo\" /&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"34px\" android:layout_weight=\"1\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"微信\" android:textColor=\"#333\" android:textSize=\"30px\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10px\" android:text=\"数亿用户都在用 , 安全可托付\" android:textColor=\"#999\" android:textSize=\"20px\" /&gt; &lt;/LinearLayout&gt; &lt;CheckBox android:id=\"@+id/cb_weixin_pay\" android:layout_width=\"34px\" android:layout_height=\"34px\" android:layout_marginRight=\"30px\" android:background=\"@drawable/dingdan_btn_xuanzhe_selector\" android:button=\"@null\" android:checked=\"false\" android:clickable=\"false\" android:enabled=\"false\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;Button android:id=\"@+id/tv_pay\" android:layout_width=\"match_parent\" android:layout_height=\"110px\" android:layout_marginLeft=\"30px\" android:layout_marginRight=\"30px\" android:layout_marginTop=\"140px\" android:background=\"@drawable/btn_main_selector\" android:gravity=\"center\" android:text=\"确认付款\" android:textColor=\"@color/color_white\" android:textSize=\"36px\" /&gt; &lt;/LinearLayout&gt; Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353package com.keqiang.highcloud.view.activity.setting; import android.annotation.SuppressLint;import android.app.AlertDialog;import android.content.DialogInterface;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.text.TextUtils;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.CheckBox;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast; import com.alipay.sdk.app.EnvUtils;import com.alipay.sdk.app.PayTask;import com.ta.utdid2.android.utils.PhoneInfoUtils;import com.tencent.mm.opensdk.modelpay.PayReq;import com.tencent.mm.opensdk.openapi.IWXAPI;import com.tencent.mm.opensdk.openapi.WXAPIFactory; import org.apache.http.conn.util.InetAddressUtils;import org.json.JSONObject; import java.io.UnsupportedEncodingException;import java.net.InetAddress;import java.net.NetworkInterface;import java.net.URLEncoder;import java.util.ArrayList;import java.util.Enumeration;import java.util.Map;import java.util.Timer;import java.util.TimerTask; import rx.Subscriber; /** * 支付宝或微信支付 * Created by zz on 2017/4/7. */public class PayActivity extends BaseActivity &#123; private TextView tvCount; private ZzTitleBar titleBar; private TextView tvPay; private static final int SDK_PAY_FLAG = 1; private static final int SDK_AUTH_FLAG = 2; private LinearLayout llAlipay; private LinearLayout llWxPay; private CheckBox cbAlipay; private CheckBox cbWxpay; //微信支付部分 private IWXAPI api; private TextView tvMinteShi; private TextView tvMinuteGe; private TextView tvSecondShi; private TextView tvSecondGe; private String time; private Handler handler = new Handler(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; countTime(time); &#125; &#125;); &#125; &#125;; private String orderId; private TextView tvProductName; private TextView tvNumber; private TextView tvType; private String orderNo; @Override public int getLayoutId() &#123; return R.layout.activity_alipay; &#125; @SuppressLint(\"HandlerLeak\") private Handler mHandler = new Handler() &#123; @SuppressWarnings(\"unused\") public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SDK_PAY_FLAG: &#123; @SuppressWarnings(\"unchecked\") PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj); /** 对于支付结果，请商户依赖服务端的异步通知结果。同步通知结果，仅作为支付结束的通知。 */ String resultInfo = payResult.getResult();// 同步返回需要验证的信息 String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为9000则代表支付成功 if (TextUtils.equals(resultStatus, \"9000\")) &#123; // 该笔订单是否真实支付成功，需要依赖服务端的异步通知。 ToastUtils.showCustomBgToast(\"支付成功！\"); Intent intent = new Intent(PayActivity.this, ShopMyOrderActivity.class); startActWithIntent(intent); closeAct(); &#125; else &#123; // 该笔订单真实的支付结果，需要依赖服务端的异步通知。 switch (resultStatus) &#123; case \"6001\": ToastUtils.showCustomBgToast(\"已取消支付操作\"); break; default: ToastUtils.showCustomBgToast(\"支付失败，错误代码：\"+resultStatus); break; &#125; &#125; break; &#125; default: break; &#125; &#125; &#125;; @Override public void initView() &#123; titleBar = (ZzTitleBar) findViewById(R.id.title_bar); tvCount = (TextView) findViewById(R.id.tv_count); tvPay = (TextView) findViewById(R.id.tv_pay); tvType = (TextView) findViewById(R.id.tv_type); tvProductName = (TextView) findViewById(R.id.tv_product_name); tvNumber = (TextView) findViewById(R.id.tv_number); llAlipay = (LinearLayout) findViewById(R.id.ll_alipay); llWxPay = (LinearLayout) findViewById(R.id.ll_wxpay); cbAlipay = (CheckBox) findViewById(R.id.cb_alipay); cbWxpay = (CheckBox) findViewById(R.id.cb_weixin_pay); tvMinteShi = (TextView) findViewById(R.id.tv_minute_shi); tvMinuteGe = (TextView) findViewById(R.id.tv_minute_ge); tvSecondShi = (TextView) findViewById(R.id.tv_second_shi); tvSecondGe = (TextView) findViewById(R.id.tv_second_ge); &#125; @Override public void initData() &#123; //微信api api = WXAPIFactory.createWXAPI(this, Constants.APP_ID, false); orderId = getIntent().getStringExtra(\"orderId\"); orderNo = getIntent().getStringExtra(\"orderNo\"); String productName = getIntent().getStringExtra(\"productName\"); String total = getIntent().getStringExtra(\"total\"); String number = getIntent().getStringExtra(\"number\"); String model = getIntent().getStringExtra(\"model\"); tvType.setText(model); tvProductName.setText(productName); tvNumber.setText(number); tvCount.setText(total); String createTime = getIntent().getStringExtra(\"createTime\"); time = DateUtil.getTimeAddMinute(createTime, 16); if (time == null) &#123; ToastUtils.showCustomBgToast(\"订单超时或已取消\"); return; &#125; handler.postDelayed(runnable, 1000); &#125; private void countTime(String time) &#123; String curTime = DateUtil.getYearMonthDayHourMinuteSecond(); long seconds = DateUtil.getSecondDuration(curTime, time); if (seconds &gt; 0) &#123; long m = seconds / 60; if (m &lt; 10) &#123; tvMinteShi.setText(\"0\"); tvMinuteGe.setText(\"\" + m); &#125; else &#123; tvMinteShi.setText(\"\" + (m / 10)); tvMinuteGe.setText(\"\" + (m % 10)); &#125; long s = seconds % 60; if (s &lt; 10) &#123; tvSecondShi.setText(\"0\"); tvSecondGe.setText(\"\" + s); &#125; else &#123; tvSecondShi.setText(\"\" + (s / 10)); tvSecondGe.setText(\"\" + (s % 10)); &#125; handler.postDelayed(runnable, 1000); &#125; else &#123; handler.removeCallbacks(runnable); ToastUtils.showCustomBgToast(\"订单超时\"); closeAct(); &#125; &#125; @Override public void initEvent() &#123; titleBar.setOnTitleBarClickListener(new ZzTitleBar.OnTitleBarClickListener() &#123; @Override public void onLeftClick() &#123; closeAct(); &#125; @Override public void onRightClick() &#123; &#125; &#125;); tvPay.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (cbAlipay.isChecked()) &#123; payV2(); &#125; else &#123; payVX(); &#125; &#125; &#125;); llAlipay.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; cbAlipay.setChecked(true); cbWxpay.setChecked(false); &#125; &#125;); llWxPay.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; cbWxpay.setChecked(true); cbAlipay.setChecked(false); &#125; &#125;); &#125; private void payVX() &#123; Api.getRegisterApi(HCApplication.getContext()) .vxPay(HCSharedUtil.getPhoneNumber(this), orderId) .compose(RxHelper.&lt;VxPayResult&gt;io_main()) .subscribe(new Subscriber&lt;VxPayResult&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; ToastUtils.showCustomBgToast(getString(R.string.no_net_text) + e.toString()); &#125; @Override public void onNext(VxPayResult vxPayResult) &#123; if (vxPayResult.getCode().equals(\"1\")) &#123; PayReq req = new PayReq(); req.appId = vxPayResult.getData().getAppid(); req.partnerId = vxPayResult.getData().getMch_id(); req.prepayId = vxPayResult.getData().getPrepay_id(); req.nonceStr = vxPayResult.getData().getOld_nonce_str(); req.packageValue = \"Sign=WXPay\"; req.sign = vxPayResult.getData().getOld_sign(); req.timeStamp = vxPayResult.getData().getTimestamp(); api.sendReq(req); closeAct(); &#125; else &#123; ToastUtils.showCustomBgToast(vxPayResult.getMsg()); &#125; &#125; &#125;); &#125; /** * 支付宝支付业务 */ public void payV2() &#123; Api.getRegisterApi(HCApplication.getContext()) .aliPay(HCSharedUtil.getPhoneNumber(this), orderId) .compose(RxHelper.&lt;AliPayResult&gt;io_main()) .subscribe(new Subscriber&lt;AliPayResult&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; ToastUtils.showCustomBgToast(getString(R.string.no_net_text) + e.toString()); &#125; @Override public void onNext(AliPayResult aliPayResult) &#123; if (aliPayResult.getCode().equals(\"1\")) &#123; final String orderInfo = aliPayResult.getOrderInfo(); Runnable payRunnable = new Runnable() &#123; @Override public void run() &#123; PayTask alipay = new PayTask(PayActivity.this); Map&lt;String, String&gt; result = alipay.payV2(orderInfo, true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); &#125; &#125;; Thread payThread = new Thread(payRunnable); payThread.start(); &#125; &#125; &#125;); &#125; @Override public void saveState(Bundle bundle) &#123; &#125; @Override public void restoreState(Bundle bundle) &#123; &#125; @Override public boolean isDefaultBackClose() &#123; return false; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); handler.removeCallbacks(runnable); handler.removeCallbacksAndMessages(null); handler = null; &#125;&#125; 注意点 支付宝支付后台需要支付宝公钥和app私钥。 支付宝支付App公私钥加密格式：Java和非Java。 微信商户平台需要设置API密钥。 微信支付后台需要二次签名。"},{"title":"Git常见问题-Android Studio重新分享项目到Github提示项目已存在","permalink":"http://zhouzhuo810.github.io/2017/10/16/Git常见问题-Android-Studio重新分享项目到Github提示项目已存在/","text":"打开Git Bash cd ${项目跟目录} git remote rm origin git remote add origin git@github.com:${用户名}/${项目名} vi .git/config 删除[remote “origin”]那一行(vi操作方法，输入i进入输入模式，删除该行之后，按下Esc，输入”:wq”保存并退出)"},{"title":"Android开源控件-常用控件地址","permalink":"http://zhouzhuo810.github.io/2017/10/12/Android开源控件-常用控件地址/","text":"图片加载Glidehttps://github.com/bumptech/glide 网络框架Okhttphttps://github.com/square/okhttp Retrofithttps://github.com/square/retrofit Okhttp-OkGohttps://github.com/jeasonlzy/okhttp-OkGo NoHttphttps://github.com/yanzhenjie/NoHttp 线程调度RxJavahttps://github.com/ReactiveX/RxJava RxAndroidhttps://github.com/ReactiveX/RxAndroid 数据库GreenDaohttps://github.com/greenrobot/greenDAO Realm-Javahttps://github.com/realm/realm-java xUtils3https://github.com/wyouflf/xUtils3 系统特性6.0动态权限AndPermissionhttps://github.com/yanzhenjie/AndPermission RxPermissionshttps://github.com/tbruyelle/RxPermissions UI控件轮播图Bannerhttps://github.com/youth5201314/banner 下拉刷新上拉加载SmartRefreshLayouthttps://github.com/scwang90/SmartRefreshLayout 图表MPAndroidCharthttps://github.com/PhilJay/MPAndroidChart Hellocharts-androidhttps://github.com/lecho/hellocharts-android 多功能列表SwipeRecyclerViewhttps://github.com/yanzhenjie/SwipeRecyclerView BaseRecyclerViewAdapterHelperhttps://github.com/CymChad/BaseRecyclerViewAdapterHelper"},{"title":"Android常用代码-多图测试数据集合","permalink":"http://zhouzhuo810.github.io/2017/10/12/Android常用代码-多图测试数据集合/","text":"123456789101112131415161718192021222324252627282930List&lt;String&gt; data = new ArrayList&lt;&gt;();data.add(\"http://p1.so.qhmsg.com/dmfd/326_204_/t01ad675c2d6620f626.jpg\");data.add(\"http://p4.so.qhmsg.com/dmfd/326_204_/t01e7b8da6f7881d669.jpg\");data.add(\"http://p2.so.qhimgs1.com/dmfd/326_204_/t016b83625d3693e592.jpg\");data.add(\"http://p0.so.qhimgs1.com/dmfd/326_204_/t019a8f0f4789b91170.jpg\");data.add(\"http://p1.so.qhimgs1.com/dmfd/326_204_/t01da7b6be4c2e7485d.jpg\");data.add(\"http://p4.so.qhimgs1.com/dmfd/326_204_/t016122ec45c5fdc5fa.jpg\");data.add(\"http://p0.so.qhmsg.com/dmfd/326_204_/t015ba6df95da81c21f.jpg\");data.add(\"http://p0.so.qhimgs1.com/dmfd/326_204_/t012c852c8f981d6a00.jpg\");data.add(\"http://p4.so.qhimgs1.com/dmfd/326_204_/t01bc3afb43b885f79a.jpg\");data.add(\"http://p2.so.qhmsg.com/dmfd/326_204_/t016f319fe697b397a7.jpg\");data.add(\"http://p4.so.qhmsg.com/dmfd/326_204_/t01260296831eb4e1c9.jpg\");data.add(\"http://p2.so.qhimgs1.com/dmfd/326_204_/t01f70e3d434b658072.jpg\");data.add(\"http://p1.so.qhimgs1.com/dmfd/326_204_/t01ff382f9ac4ff3b41.jpg\");data.add(\"http://p3.so.qhimgs1.com/dmfd/326_204_/t0136c51e038b8eb443.jpg\");data.add(\"http://p4.so.qhimgs1.com/dmfd/326_204_/t01510b700b852c19ea.jpg\");data.add(\"http://p2.so.qhmsg.com/dmfd/326_204_/t01ee2021295046db97.jpg\");data.add(\"http://p2.so.qhimgs1.com/dmfd/326_204_/t011827d91512e21f1e.jpg\");data.add(\"http://p4.so.qhimgs1.com/dmfd/326_204_/t01e0d10a1d9c967b6a.jpg\");data.add(\"http://p5.so.qhimgs1.com/dmfd/326_204_/t014dee2f747c97027b.jpg\");data.add(\"http://p0.so.qhmsg.com/dmfd/326_204_/t015937ffe391b99cbf.jpg\");data.add(\"http://p2.so.qhimgs1.com/dmfd/326_204_/t01c8781008ac43b8b2.jpg\");data.add(\"http://p0.so.qhimgs1.com/dmfd/326_204_/t0157cf838838b73380.jpg\");data.add(\"http://p2.so.qhimgs1.com/dmfd/326_204_/t01486d9595e7e72a7e.jpg\");data.add(\"http://p1.so.qhmsg.com/dmfd/326_204_/t016ddb799a12726bc6.jpg\");data.add(\"http://p4.so.qhimgs1.com/dmfd/326_204_/t01cbfab89caa120e9a.jpg\");data.add(\"http://p0.so.qhmsg.com/dmfd/326_204_/t01fd0af7e89abd4615.jpg\");data.add(\"http://p2.so.qhimgs1.com/dmfd/326_204_/t0155c730d796084202.jpg\");data.add(\"http://p0.so.qhmsg.com/dmfd/326_204_/t01007ed5e564c9c99f.jpg\");data.add(\"http://p1.so.qhimgs1.com/dmfd/326_204_/t0127d36bd652e5f6ed.jpg\");"},{"title":"Android常用代码-切换主题","permalink":"http://zhouzhuo810.github.io/2017/10/12/Android常用代码-切换主题/","text":"核心代码1234567891011121314private void setThemeColor(int colorPrimary, int colorPrimaryDark) &#123; mToolbar.setBackgroundResource(colorPrimary); mToolbar.setTitleTextColor(ContextCompat.getColor(this, android.R.color.white)); mToolbar.setNavigationIcon(R.drawable.ic_arrow_back_white_24dp); if (Build.VERSION.SDK_INT &gt;= 21) &#123; getWindow().setStatusBarColor(ContextCompat.getColor(this, colorPrimaryDark)); &#125; if (Build.VERSION.SDK_INT &gt;= 23) &#123; Window window = getWindow(); int systemUiVisibility = window.getDecorView().getSystemUiVisibility(); systemUiVisibility &amp;= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR; window.getDecorView().setSystemUiVisibility(systemUiVisibility); &#125;&#125; 使用方式1setThemeColor(R.color.colorPrimary, R.color.colorPrimaryDark);"},{"title":"Android疑难杂症-ViewPager+PhotoView问题","permalink":"http://zhouzhuo810.github.io/2017/10/11/Android疑难杂症-ViewPager-PhotoView问题/","text":"版本说明PhotoView版本： 12//photoViewcompile &apos;com.mcxiaoke.photoview:library:1.2.3&apos; 问题描述 ViewPager+PhotoView缩放操作时报错 ViewPager+PhotoView左右滑动图片加载错位 指定显示第几张图片 解决方式重写ViewPager的onInterceptTouchEvent方法123456789@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; try &#123; return super.onInterceptTouchEvent(ev); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); return false; &#125;&#125; 定义Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static class MultiImagePageAdapter extends PagerAdapter &#123; private PhotoViewAttacher.OnViewTapListener onViewTapListener; //设置点击任意一张图片结束预览 public void setOnViewTapListener(PhotoViewAttacher.OnViewTapListener onViewTapListener) &#123; this.onViewTapListener = onViewTapListener; &#125; private final DisplayImageOptions options; private List&lt;String&gt; imgs; public MultiImagePageAdapter(List&lt;String&gt; imgs) &#123; options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.product_default) .showImageForEmptyUri(R.drawable.product_default) .showImageOnFail(R.drawable.product_default) .bitmapConfig(Bitmap.Config.ARGB_8888) .imageScaleType(ImageScaleType.EXACTLY) .cacheInMemory(true) .cacheOnDisk(true) .build(); this.imgs = imgs; &#125; @Override public int getCount() &#123; return imgs == null ? 0 : imgs.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; PhotoView photoView = new PhotoView(container.getContext()); //关键 container.addView(photoView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); photoView.setScaleType(ImageView.ScaleType.FIT_CENTER); photoView.setOnViewTapListener(onViewTapListener); //网络加载 HCApplication.getImageLoader().displayImage(imgs.get(position), photoView, options); return photoView; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; //别忘了 container.removeView((View) object); &#125;&#125; 布局123456&lt;com.keqiang.highcloud.view.widget.HackyViewPager android:id=\"@+id/view_pager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/com.keqiang.highcloud.view.widget.HackyViewPager&gt; 初始化1234567891011121314151617List&lt;String&gt; imgs = getIntent().getStringArrayListExtra(\"imgs\");int position = getIntent().getIntExtra(\"position\", 0);if (imgs != null &amp;&amp; imgs.size() &gt; 0) &#123; MultiImagePageAdapter adapter = new MultiImagePageAdapter(imgs); adapter.setOnViewTapListener(new PhotoViewAttacher.OnViewTapListener() &#123; @Override public void onViewTap(View view, float x, float y) &#123; if (Build.VERSION.SDK_INT &gt;= 21) &#123; onBackPressed(); &#125; else &#123; closeAct(); &#125; &#125; &#125;); viewPager.setAdapter(adapter); viewPager.setCurrentItem(position);&#125; 调用1234567891011Intent intent = new Intent(activity, MultiImagePreviewActivity.class);//传入图片和位置信息intent.putExtra(&quot;imgs&quot;, imgs);intent.putExtra(&quot;position&quot;, position);if (Build.VERSION.SDK_INT &gt;= 21) &#123; ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, banner, getString(R.string.transition_product_img)); ActivityCompat.startActivity(activity, intent, options.toBundle());&#125; else &#123; startActWithIntent(intent);&#125; Activity实例 布局 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorBlack\" android:orientation=\"vertical\"&gt; &lt;com.keqiang.highcloud.view.widget.HackyViewPager android:id=\"@+id/view_pager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/com.keqiang.highcloud.view.widget.HackyViewPager&gt;&lt;/LinearLayout&gt; java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import android.graphics.Bitmap;import android.os.Build;import android.os.Bundle;import android.support.v4.view.PagerAdapter;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import com.nostra13.universalimageloader.core.DisplayImageOptions;import com.nostra13.universalimageloader.core.assist.ImageScaleType;import java.util.List;import uk.co.senab.photoview.PhotoView;import uk.co.senab.photoview.PhotoViewAttacher;/** * Created by zhouzhuo810 on 2017/10/11. */public class MultiImagePreviewActivity extends BaseActivity &#123; private HackyViewPager viewPager; @Override public int getLayoutId() &#123; return R.layout.activity_multi_img_preview; &#125; @Override public void initView() &#123; viewPager = (HackyViewPager) findViewById(R.id.view_pager); &#125; @Override public void initData() &#123; List&lt;String&gt; imgs = getIntent().getStringArrayListExtra(&quot;imgs&quot;); int position = getIntent().getIntExtra(&quot;position&quot;, 0); if (imgs != null &amp;&amp; imgs.size() &gt; 0) &#123; MultiImagePageAdapter adapter = new MultiImagePageAdapter(imgs); adapter.setOnViewTapListener(new PhotoViewAttacher.OnViewTapListener() &#123; @Override public void onViewTap(View view, float x, float y) &#123; if (Build.VERSION.SDK_INT &gt;= 21) &#123; onBackPressed(); &#125; else &#123; closeAct(); &#125; &#125; &#125;); viewPager.setAdapter(adapter); viewPager.setCurrentItem(position); &#125; &#125; public static class MultiImagePageAdapter extends PagerAdapter &#123; private PhotoViewAttacher.OnViewTapListener onViewTapListener; public void setOnViewTapListener(PhotoViewAttacher.OnViewTapListener onViewTapListener) &#123; this.onViewTapListener = onViewTapListener; &#125; private final DisplayImageOptions options; private List&lt;String&gt; imgs; public MultiImagePageAdapter(List&lt;String&gt; imgs) &#123; options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.product_default) .showImageForEmptyUri(R.drawable.product_default) .showImageOnFail(R.drawable.product_default) .bitmapConfig(Bitmap.Config.ARGB_8888) .imageScaleType(ImageScaleType.EXACTLY) .cacheInMemory(true) .cacheOnDisk(true) .build(); this.imgs = imgs; &#125; @Override public int getCount() &#123; return imgs == null ? 0 : imgs.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; PhotoView photoView = new PhotoView(container.getContext()); container.addView(photoView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); photoView.setScaleType(ImageView.ScaleType.FIT_CENTER); photoView.setOnViewTapListener(onViewTapListener); HCApplication.getImageLoader().displayImage(imgs.get(position), photoView, options); return photoView; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; &#125; @Override public void initEvent() &#123; &#125; @Override public void saveState(Bundle bundle) &#123; &#125; @Override public void restoreState(Bundle bundle) &#123; &#125; @Override public boolean isDefaultBackClose() &#123; return false; &#125;&#125;"},{"title":"JavaEE-Tomcat使用服务开机自启动","permalink":"http://zhouzhuo810.github.io/2017/10/04/JavaEE-Tomcat使用服务开机自启动/","text":"前提条件 JDK和Tomcat同为32位或同为64位。 配置JDK环境变量。 配置Tomcat环境变量。 设置服务 打开cmd 切换到tomcat bin目录 运行下列命令 1service.bat install Tomcat 卸载服务 打开cmd 切换到tomcat bin目录 运行下列命令 1service.bat uninstall Tomcat 设置服务开机自启动 打开服务管理 设置为自动，应用。"},{"title":"Android疑难杂症-根据资源名称获取资源Id","permalink":"http://zhouzhuo810.github.io/2017/10/04/Android疑难杂症-根据资源名称获取资源Id/","text":"12Resources resources = context.getResources();int id= getResources().getIdentifier(\"图标名称(不带后缀)\", \"drawable\", \"包名\"); 应用场景 用数字图片表示剩余天数 12345678910111213141516171819private void setLeftDays(int days) &#123; String dayStr = Integer.toString(days); llLeftDays.removeAllViews(); for (int i=dayStr.length()-1; i&gt;0; i--) &#123; int d = (int) (days / (Math.pow(10, i))); int s = d%10; ImageView iv = new ImageView(context); iv.setImageResource(getResources().getIdentifier(\"image_number\"+s, \"drawable\", \"me.zhouzhuo810.test\")); iv.setLayoutParams(new LinearLayout.LayoutParams(ViewUtil.scaleTextValue(context, 52) ,ViewUtil.scaleTextValue(context, 64))); llLeftDays.addView(iv); &#125; int l = days%10; ImageView iv = new ImageView(context); iv.setImageResource(getResources().getIdentifier(\"image_number\"+l, \"drawable\", \"me.zhouzhuo810.test\")); iv.setLayoutParams(new LinearLayout.LayoutParams(ViewUtil.scaleTextValue(context, 52) ,ViewUtil.scaleTextValue(context, 64))); llLeftDays.addView(iv);&#125; 工具封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 资源文件工具类 */public class ResourcesUtils &#123; private static final String RES_ID = \"id\"; private static final String RES_STRING = \"string\"; private static final String RES_DRABLE = \"drable\"; private static final String RES_LAYOUT = \"layout\"; private static final String RES_STYLE = \"style\"; private static final String RES_COLOR = \"color\"; private static final String RES_DIMEN = \"dimen\"; private static final String RES_ANIM = \"anim\"; private static final String RES_MENU = \"menu\"; /** * 获取资源文件的id * @param context * @param resName * @return */ public static int getId(Context context,String resName)&#123; return getResId(context,resName,RES_ID); &#125; /** * 获取资源文件string的id * @param context * @param resName * @return */ public static int getStringId(Context context,String resName)&#123; return getResId(context,resName,RES_STRING); &#125; /** * 获取资源文件drable的id * @param context * @param resName * @return */ public static int getDrableId(Context context,String resName)&#123; return getResId(context,resName,RES_DRABLE); &#125; /** * 获取资源文件layout的id * @param context * @param resName * @return */ public static int getLayoutId(Context context,String resName)&#123; return getResId(context,resName,RES_LAYOUT); &#125; /** * 获取资源文件style的id * @param context * @param resName * @return */ public static int getStyleId(Context context,String resName)&#123; return getResId(context,resName,RES_STYLE); &#125; /** * 获取资源文件color的id * @param context * @param resName * @return */ public static int getColorId(Context context,String resName)&#123; return getResId(context,resName,RES_COLOR); &#125; /** * 获取资源文件dimen的id * @param context * @param resName * @return */ public static int getDimenId(Context context,String resName)&#123; return getResId(context,resName,RES_DIMEN); &#125; /** * 获取资源文件ainm的id * @param context * @param resName * @return */ public static int getAnimId(Context context,String resName)&#123; return getResId(context,resName,RES_ANIM); &#125; /** * 获取资源文件menu的id */ public static int getMenuId(Context context,String resName)&#123; return getResId(context,resName,RES_MENU); &#125; /** * 获取资源文件ID * @param context * @param resName * @param defType * @return */ public static int getResId(Context context,String resName,String defType)&#123; return context.getResources().getIdentifier(resName, defType, context.getPackageName()); &#125;&#125;"},{"title":"Android支付宝支付-返回签名错误问题","permalink":"http://zhouzhuo810.github.io/2017/09/30/Android支付宝支付-返回签名错误问题/","text":"解决方案首先，检查服务端公钥是否为支付宝公钥。（不是App公钥）。其次，检查服务端APP私钥是否和支付宝平台的APP公钥匹配(推荐RSA2)；最后，沙箱环境是否注释。"},{"title":"Android微信支付返回-1问题解决","permalink":"http://zhouzhuo810.github.io/2017/09/30/Android微信支付返回-1问题解决/","text":"整体流程回顾1234567891011121314 商户系统和微信支付系统主要交互说明： 步骤1：用户在商户APP中选择商品，提交订单，选择微信支付。 步骤2：商户后台收到用户支付单，调用微信支付统一下单接口。参见【统一下单API】。 步骤3：统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appid，partnerid，prepayid，noncestr，timestamp，package。注意：package的值格式为Sign=WXPay 步骤4：商户APP调起微信支付。api参见本章节【app端开发步骤说明】 步骤5：商户后台接收支付通知。api参见【支付结果通知API】 步骤6：商户后台查询支付结果。，api参见【查询订单API】 问题解决首先，检查微信平台的APP ID是否正确；其次，检查微信商户平台的API密钥(随机32位即可)是否设置且正确使用；随机字符串生成地址 然后，检查微信平台的包名和签名(注意字母小写)是否配置并正确；再然后，检查服务端是否二次签名；并且二次签名是否正确；最后，检查返回的时间戳是不是使用二次签名的时间戳；返回的随机字符串是不是二次签名时的随机字符串。"},{"title":"Android常用demo-微信支付","permalink":"http://zhouzhuo810.github.io/2017/09/13/Android常用demo-微信支付/","text":"微信支付百度云下载 1提取码： 79nk"},{"title":"JavaEE-文件存储","permalink":"http://zhouzhuo810.github.io/2017/09/07/JavaEE-文件存储/","text":"文件存储工具整理 随机名字存储 指定文件名存储 字节存储 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.nio.charset.Charset; /** * Created by admin on 2017/7/22. */public class FileUtils &#123; public static String saveFileToPathWithRandomName(String content, String path) throws IOException &#123; // 创建目录 File dir = new File(path); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 读取文件流并保持在指定路径 String filename = System.currentTimeMillis() + \".txt\"; String mPath = path + File.separator + filename; System.out.println(path); OutputStream outputStream = new FileOutputStream(mPath); byte[] buffer = content.getBytes(Charset.forName(\"utf-8\")); outputStream.write(buffer); outputStream.flush(); outputStream.close(); return filename; &#125; public static String saveFileToPathWithName(String content, String path, String filename) throws IOException &#123; // 创建目录 File dir = new File(path); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 读取文件流并保持在指定路径 String mPath = path + File.separator + filename; System.out.println(path); OutputStream outputStream = new FileOutputStream(mPath); byte[] buffer = content.getBytes(Charset.forName(\"utf-8\")); outputStream.write(buffer); outputStream.flush(); outputStream.close(); return filename; &#125; public static void deleteFiles(String dir) &#123; File file = new File(dir); if (!file.exists()) &#123; return; &#125; if (file.isDirectory()) &#123; File[] files = file.listFiles(); if (files != null &amp;&amp; files.length &gt; 0) &#123; for (File file1 : files) &#123; file1.delete(); &#125; &#125; &#125; &#125; public static String saveFile(byte[] data, String dirName, String fileName) &#123; HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); String realPath = request.getRealPath(\"\"); String newpath = realPath + File.separator + dirName; File file = new File(newpath); if (!file.exists()) &#123; file.mkdirs(); &#125; String filePath = newpath + File.separator + fileName; try &#123; FileOutputStream fos = new FileOutputStream(new File(filePath), false); fos.write(data); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return filePath; &#125;&#125;"},{"title":"JavaEE-文件压缩与解压","permalink":"http://zhouzhuo810.github.io/2017/09/07/JavaEE-文件压缩与解压/","text":"文件压缩与解压工具整理 文件或文件夹压缩 文件解压 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream; public class ZipUtils &#123; private ZipUtils()&#123; &#125; public static void doCompress(String srcFile, String zipFile) throws IOException &#123; doCompress(new File(srcFile), new File(zipFile)); &#125; /** * 文件压缩 * @param srcFile 目录或者单个文件 * @param zipFile 压缩后的ZIP文件 */ public static void doCompress(File srcFile, File zipFile) throws IOException &#123; ZipOutputStream out = null; try &#123; out = new ZipOutputStream(new FileOutputStream(zipFile)); doCompress(srcFile, out); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; out.close();//记得关闭资源 &#125; &#125; public static void doCompress(String filelName, ZipOutputStream out) throws IOException&#123; doCompress(new File(filelName), out); &#125; public static void doCompress(File file, ZipOutputStream out) throws IOException&#123; doCompress(file, out, \"\"); &#125; public static void doCompress(File inFile, ZipOutputStream out, String dir) throws IOException &#123; if ( inFile.isDirectory() ) &#123; File[] files = inFile.listFiles(); if (files!=null &amp;&amp; files.length&gt;0) &#123; for (File file : files) &#123; String name = inFile.getName(); if (!\"\".equals(dir)) &#123; name = dir + \"/\" + name; &#125; ZipUtils.doCompress(file, out, name); &#125; &#125; &#125; else &#123; ZipUtils.doZip(inFile, out, dir); &#125; &#125; public static void doZip(File inFile, ZipOutputStream out, String dir) throws IOException &#123; String entryName = null; if (!\"\".equals(dir)) &#123; entryName = dir + \"/\" + inFile.getName(); &#125; else &#123; entryName = inFile.getName(); &#125; ZipEntry entry = new ZipEntry(entryName); out.putNextEntry(entry); int len = 0 ; byte[] buffer = new byte[1024]; FileInputStream fis = new FileInputStream(inFile); while ((len = fis.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, len); out.flush(); &#125; out.closeEntry(); fis.close(); &#125; public static void main(String[] args) throws IOException &#123; doCompress(\"D:/java/\", \"D:/java.zip\"); &#125; &#125;"},{"title":"JavaEE-SpingMVC之log4j日志配置","permalink":"http://zhouzhuo810.github.io/2017/08/23/JavaEE-SpingMVC之log4j日志配置/","text":"web.xml 添加配置12345678910111213141516&lt;!-- Spring的log4j监听器 --&gt;&lt;context-param&gt; &lt;param-name&gt;webAppRootKey&lt;/param-name&gt; &lt;param-value&gt;webapp.root1&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;6000&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;&lt;/listener&gt; resources中添加log4j.properties 注意：webAppRootKey的值和${webapp.root1}的内容相对相。 123456789101112131415161718192021222324252627282930313233343536373839404142### 设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ####log4j.appender.stdout = org.apache.log4j.ConsoleAppender#log4j.appender.stdout.Target = System.out#log4j.appender.stdout.layout = org.apache.log4j.PatternLayout#log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = $&#123;webapp.root1&#125;/WEB-INF/logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = INFOlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%X&#123;ip&#125;] [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =$&#123;webapp.root1&#125;/WEB-INF/logs/error.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERRORlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%X&#123;ip&#125;] [ %t:%r ] - [ %p ] %m%n#log4j.rootLogger=INFO,CONSOLE,DAILY_ALL#console log#log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender#log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout#log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t] %-5p %c - %m%n##all log#log4j.appender.DAILY_ALL=org.apache.log4j.DailyRollingFileAppender#log4j.appender.DAILY_ALL.layout=org.apache.log4j.PatternLayout#log4j.appender.DAILY_ALL.layout.ConversionPattern=&quot;%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %-50.50c(%L) - %m%n##$&#123;webapp.root&#125; == the path of your tomcat path#log4j.appender.DAILY_ALL.File=$&#123;webapp.root&#125;/WEB-INF/logs/app.log## General Apache libraries#log4j.logger.org.apache=WARN## Spring#log4j.logger.org.springframework=WARN# emaillog4j.logger.com.alexgaoyh.util.email=INFO, emaillog4j.appender.email=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.email.layout=org.apache.log4j.PatternLayoutlog4j.appender.email.layout.ConversionPattern=&quot;%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %-50.50c(%L) - %m%nlog4j.appender.email.File=$&#123;webapp.root1&#125;/WEB-INF/logs/email/email.log"},{"title":"Android疑难杂症-串口通讯","permalink":"http://zhouzhuo810.github.io/2017/08/23/Android疑难杂症-串口通讯/","text":"usb-serial-for-android 在这个项目的基础上我将串口通信的功能封装了起来，用起来更加简单了。 Github传送门：OkUSB OkUSB一个简洁的Android串口通信框架。 功能简介 支持设置波特率 支持设置数据位 支持设置停止位 支持设置校验位 支持DTS和RTS 支持串口连接状态监听 ## 用法简介 Gradle12345678910allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125;dependencies &#123; compile &apos;com.github.zhouzhuo810:OkUSB:1.0.0&apos;&#125; 具体用法1.在AndroidManifest.xml中添加如下特性： 1&lt;uses-feature android:name=\"android.hardware.usb.host\" /&gt; 在需要连接串口的Activity中添加： 123456&lt;intent-filter&gt; &lt;action android:name=\"android.hardware.usb.action.USB_DEVICE_ATTACHED\" /&gt;&lt;/intent-filter&gt;&lt;meta-data android:name=\"android.hardware.usb.action.USB_DEVICE_ATTACHED\" android:resource=\"@xml/device_filter\" /&gt; 2.在res文件夹创建xml文件夹，新建device_filter.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;!-- 要进行通信的USB设备的供应商ID（VID）和产品识别码（PID）--&gt; &lt;usb-device vendor-id=\"0403\" product-id=\"6001\" /&gt;&lt;/resources&gt; 3.前面都是准备工作，这里才真正使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 //初始化usb = new USB.USBBuilder(this) .setBaudRate(115200) //波特率 .setDataBits(8) //数据位 .setStopBits(UsbSerialPort.STOPBITS_1) //停止位 .setParity(UsbSerialPort.PARITY_NONE) //校验位 .setMaxReadBytes(20) //接受数据最大长度 .setReadDuration(500) //读数据间隔时间 .setDTR(false) //DTR enable .setRTS(false) //RTS enable .build(); //实现监听连接状态和数据收发。usb.setOnUsbChangeListener(new USB.OnUsbChangeListener() &#123; @Override public void onUsbConnect() &#123; Toast.makeText(MainActivity.this, \"conencted\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUsbDisconnect() &#123; Toast.makeText(MainActivity.this, \"disconencted\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDataReceive(byte[] data) &#123; tvResult.setText(new String(data, Charset.forName(\"GB2312\"))); &#125; @Override public void onUsbConnectFailed() &#123; Toast.makeText(MainActivity.this, \"connect fail\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onPermissionGranted() &#123; Toast.makeText(MainActivity.this, \"permission ok\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onPermissionRefused() &#123; Toast.makeText(MainActivity.this, \"permission fail\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDriverNotSupport() &#123; Toast.makeText(MainActivity.this, \"no driver\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onWriteDataFailed(String error) &#123; Toast.makeText(MainActivity.this, \"write fail\" + error, Toast.LENGTH_SHORT).show(); &#125; @Override public void onWriteSuccess(int num) &#123; Toast.makeText(MainActivity.this, \"write ok \" + num, Toast.LENGTH_SHORT).show(); &#125;&#125;); 4.如果是Activity，可以在onDestroy中调用如下代码关闭串口。 1234if (usb != null) &#123; usb.destroy();&#125;"},{"title":"JavaEE-SpringMVC之获取项目根目录","permalink":"http://zhouzhuo810.github.io/2017/08/23/JavaEE-SpringMVC之获取项目根目录/","text":"代码很少，但是很有用12HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();String realPath = request.getRealPath(\"\");"},{"title":"Android常用代码-复制与粘贴","permalink":"http://zhouzhuo810.github.io/2017/08/23/Android常用代码-复制与粘贴/","text":"核心代码12ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);cm.setPrimaryClip(ClipData.newPlainText(label, text)); 工具类封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import android.content.ClipData;import android.content.ClipboardManager;import android.content.Context;import android.content.Intent;import android.net.Uri;import android.support.annotation.RequiresApi;/** * Android 复制粘贴工具 * Created by zhouzhuo810 on 2017/8/12. */public class CopyUtils &#123; public static void copyUrl(Context context,CharSequence label, String url) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); cm.setPrimaryClip(ClipData.newRawUri(label, Uri.parse(url))); &#125; public static void copyUri(Context context,CharSequence label, Uri uri) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); cm.setPrimaryClip(ClipData.newRawUri(label, uri)); &#125; @RequiresApi(value = 16) public static void copyHtml(Context context,CharSequence label, String text, String html) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); cm.setPrimaryClip(ClipData.newHtmlText(label,text, html)); &#125; public static void copyPlainText(Context context, CharSequence label, String text) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); cm.setPrimaryClip(ClipData.newPlainText(label, text)); &#125; public static void copyIntent(Context context,CharSequence label, Intent intent) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); cm.setPrimaryClip(ClipData.newIntent(label, intent)); &#125; public static CharSequence getCopyPlainText(Context context) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); return cm.getPrimaryClip().getItemAt(0).getText(); &#125; public static Intent getCopyIntent(Context context) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); return cm.getPrimaryClip().getItemAt(0).getIntent(); &#125; @RequiresApi(value = 16) public static CharSequence getCopyHtmlText(Context context) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); return cm.getPrimaryClip().getItemAt(0).getHtmlText(); &#125; public static Uri getCopyUri(Context context) &#123; ClipboardManager cm = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); return cm.getPrimaryClip().getItemAt(0).getUri(); &#125; &#125;"},{"title":"JavaEE-使用itext生成PDF总结","permalink":"http://zhouzhuo810.github.io/2017/08/18/JavaEE-使用itext生成PDF总结/","text":"添加pom依赖123456789101112&lt;!-- pdf start--&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- pdf end --&gt; 基本功能添加普通文字(不换行)12345678910111213141516171819private void addText(Document document, String text, Font font) &#123; if (font == null) &#123; Chunk chunk = new Chunk(text == null ? \"\" : text); try &#123; document.add(chunk); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; font.setSize(12f); font.setStyle(Font.NORMAL); Chunk chunk = new Chunk(text == null ? \"\" : text, font); try &#123; document.add(chunk); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 添加普通文字(换行)12345678910111213141516171819private void addTextLine(Document document, String text, Font font) &#123; if (font == null) &#123; Chunk chunk = new Chunk((text == null ? \"\" : text) + \"\\n\"); try &#123; document.add(chunk); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; font.setSize(12f); font.setStyle(Font.NORMAL); Chunk chunk = new Chunk((text == null ? \"\" : text) + \"\\n\", font); try &#123; document.add(chunk); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 添加下划线文字(带超链接)1234567891011121314151617/** * 添加下划线(带超链接) * * @param document Document对象 * @param text 链接文字 * @param fontPath 字体路径 * @throws IOException 异常 * @throws DocumentException 异常 */private void addUnderLineText(Document document, String text, String fontPath) throws IOException, DocumentException &#123; Font font = new Font(BaseFont.createFont(fontPath + \"Arial.ttf\", BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED), 12f, Font.UNDERLINE); font.setColor(BaseColor.BLUE); Anchor anchor = new Anchor(text, font); anchor.setReference(text); anchor.setName(text); document.add(anchor);&#125; 添加表格 方法封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /** * 添加表格 * * @param document Document对象 * @param tableTitle 表格标题 * @param titles 标题 * @param widthRatio 标题宽的比例 * @param values 内容 * @param titleBgColor 标题行背景颜色 * @param font 字体 * @throws DocumentException 异常 */private List&lt;PdfPRow&gt; addTable(Document document, String tableTitle, String[] titles, float[] widthRatio, String[][] values, BaseColor titleBgColor, Font font) throws DocumentException &#123; //添加表格标题 font.setSize(14f); font.setStyle(Font.BOLD); Chunk paragraph = new Chunk(tableTitle == null ? \"\" : tableTitle, font); try &#123; document.add(paragraph); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; font.setSize(12f); font.setStyle(Font.NORMAL); //添加表格 PdfPTable inter = new PdfPTable(titles.length); inter.setWidthPercentage(100); // 宽度100%填充 inter.setSpacingBefore(1f); // 前间距 inter.setSpacingAfter(1f); // 后间距 List&lt;PdfPRow&gt; listRow = inter.getRows(); //行 //设置列宽比例 inter.setWidths(widthRatio); //标题 PdfPCell cells[] = new PdfPCell[titles.length]; PdfPRow titleRow = new PdfPRow(cells); //单元格 for (int i = 0; i &lt; titles.length; i++) &#123; cells[i] = new PdfPCell(new Paragraph(titles[i], font)); cells[i].setBackgroundColor(titleBgColor == null ? BaseColor.LIGHT_GRAY : titleBgColor); cells[i].setPaddingTop(6f); cells[i].setPaddingBottom(6f); &#125; //把第一行添加到集合 listRow.add(titleRow); for (String[] value : values) &#123; PdfPCell childCells[] = new PdfPCell[value.length]; PdfPRow row = new PdfPRow(childCells); //添加列 for (int i = 0; i &lt; value.length; i++) &#123; childCells[i] = new PdfPCell(new Paragraph(value[i], font));//单元格内容 childCells[i].setPaddingTop(4f); childCells[i].setPaddingBottom(4f); &#125; //添加行 listRow.add(row); &#125; document.add(inter); return listRow;&#125; 用法示例 123456789101112131415161718192021222324252627282930private void pdfAddRequestHeaders(Document document, String projectId, String id, Font font) throws DocumentException &#123; List&lt;RequestHeaderEntity&gt; globals = mRequestHeaderService.getGlobalRequestHeaders(projectId); List&lt;RequestHeaderEntity&gt; args = mRequestHeaderService.getBaseDao().executeCriteria(ResponseArgUtils.getArgByInterfaceId(id)); if (globals != null &amp;&amp; globals.size() &gt; 0) &#123; //设置列宽 float[] columnWidths = &#123;3f, 2f, 5f&#125;; String[][] values = new String[args.size()][3]; for (int i = 0; i &lt; args.size(); i++) &#123; RequestHeaderEntity entity = args.get(i); values[i][0] = entity.getName(); values[i][1] = entity.getValue() == null ? \"\" : entity.getValue(); values[i][2] = entity.getNote() == null ? \"\" : entity.getNote(); &#125; addTable(document, \"全局请求头\", new String[]&#123;\"名称\", \"默认值\", \"说明\"&#125;, columnWidths, values, null, font); &#125; if (args != null &amp;&amp; args.size() &gt; 0) &#123; //设置列宽 float[] columnWidths = &#123;3f, 2f, 5f&#125;; String[][] values = new String[args.size()][3]; for (int i = 0; i &lt; args.size(); i++) &#123; RequestHeaderEntity entity = args.get(i); values[i][0] = entity.getName(); values[i][1] = entity.getValue() == null ? \"\" : entity.getValue(); values[i][2] = entity.getNote() == null ? \"\" : entity.getNote(); &#125; addTable(document, \"其他请求头\", new String[]&#123;\"名称\", \"默认值\", \"说明\"&#125;, columnWidths, values, null, font); &#125;&#125; 难点添加页码 使用 123456PdfWriter pdfWriter = PdfWriter.getInstance(document, new FileOutputStream(filePath));PdfReportM1HeaderFooter footer = new PdfReportM1HeaderFooter();pdfWriter.setPageEvent(footer);//打开文档document.open();//... ... 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * Project Name:report * File Name:PdfReportM1HeaderFooter.java * Package Name:com.riambsoft.report.pdf * Date:2013-9-16上午08:59:00 * Copyright (c) 2013, riambsoft All Rights Reserved. */ import java.io.IOException; import com.itextpdf.text.Document;import com.itextpdf.text.DocumentException;import com.itextpdf.text.Element;import com.itextpdf.text.Font;import com.itextpdf.text.PageSize;import com.itextpdf.text.Phrase;import com.itextpdf.text.Rectangle;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.ColumnText;import com.itextpdf.text.pdf.PdfContentByte;import com.itextpdf.text.pdf.PdfPageEventHelper;import com.itextpdf.text.pdf.PdfTemplate;import com.itextpdf.text.pdf.PdfWriter; public class PdfReportM1HeaderFooter extends PdfPageEventHelper &#123; /** * 页眉 */ public String header = \"\"; /** * 文档字体大小，页脚页眉最好和文本大小一致 */ public int presentFontSize = 12; /** * 文档页面大小，最好前面传入，否则默认为A4纸张 */ public Rectangle pageSize = PageSize.A4; // 模板 public PdfTemplate total; // 基础字体对象 public BaseFont bf = null; // 利用基础字体生成的字体对象，一般用于生成中文文字 public Font fontDetail = null; /** * * Creates a new instance of PdfReportM1HeaderFooter 无参构造方法. * */ public PdfReportM1HeaderFooter() &#123; &#125; /** * * Creates a new instance of PdfReportM1HeaderFooter 构造方法. * * @param yeMei * 页眉字符串 * @param presentFontSize * 数据体字体大小 * @param pageSize * 页面文档大小，A4，A5，A6横转翻转等Rectangle对象 */ public PdfReportM1HeaderFooter(String yeMei, int presentFontSize, Rectangle pageSize) &#123; this.header = yeMei; this.presentFontSize = presentFontSize; this.pageSize = pageSize; &#125; public void setHeader(String header) &#123; this.header = header; &#125; public void setPresentFontSize(int presentFontSize) &#123; this.presentFontSize = presentFontSize; &#125; /** * * TODO 文档打开时创建模板 * * @see com.itextpdf.text.pdf.PdfPageEventHelper#onOpenDocument(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document) */ public void onOpenDocument(PdfWriter writer, Document document) &#123; total = writer.getDirectContent().createTemplate(70, 70);// 共 页 的矩形的长宽高 &#125; /** * * TODO 关闭每页的时候，写入页眉，写入'第几页共'这几个字。 * * @see com.itextpdf.text.pdf.PdfPageEventHelper#onEndPage(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document) */ public void onEndPage(PdfWriter writer, Document document) &#123; try &#123; if (bf == null) &#123; bf = BaseFont.createFont(\"STSong-Light\", \"UniGB-UCS2-H\", false); &#125; if (fontDetail == null) &#123; fontDetail = new Font(bf, presentFontSize, Font.NORMAL);// 数据体字体 &#125; &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 1.写入页眉 ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_LEFT, new Phrase(header, fontDetail), document.left(), document.top() + 20, 0); // 2.写入前半部分的 第 X页/共 int pageS = writer.getPageNumber(); String foot1 = \"第 \" + pageS + \" 页 /共\"; Phrase footer = new Phrase(foot1, fontDetail); // 3.计算前半部分的foot1的长度，后面好定位最后一部分的'Y页'这俩字的x轴坐标，字体长度也要计算进去 = len float len = bf.getWidthPoint(foot1, presentFontSize); // 4.拿到当前的PdfContentByte PdfContentByte cb = writer.getDirectContent(); //自己增加的/* if (pageS == 1) &#123; Phrase footerLeft = new Phrase(\"\", fontDetail); ColumnText.showTextAligned(cb, Element.ALIGN_LEFT, footerLeft, document.left(), document.bottom() - 20, 0); &#125;*/ // 5.写入页脚1，x轴就是(右margin+左margin + right() -left()- len)/2.0F 再给偏移20F适合人类视觉感受，否则肉眼看上去就太偏左了 ,y轴就是底边界-20,否则就贴边重叠到数据体里了就不是页脚了；注意Y轴是从下往上累加的，最上方的Top值是大于Bottom好几百开外的。 ColumnText.showTextAligned(cb, Element.ALIGN_CENTER, footer, (document.rightMargin() + document.right() + document.leftMargin() - document.left() - len) / 2.0F + 20F, document.bottom() - 20, 0); // 6.写入页脚2的模板（就是页脚的Y页这俩字）添加到文档中，计算模板的和Y轴,X=(右边界-左边界 - 前半部分的len值)/2.0F + len ， y 轴和之前的保持一致，底边界-20 cb.addTemplate(total, (document.rightMargin() + document.right() + document.leftMargin() - document.left()) / 2.0F + 20F, document.bottom() - 20); // 调节模版显示的位置 &#125; /** * * TODO 关闭文档时，替换模板，完成整个页眉页脚组件 * * @see com.itextpdf.text.pdf.PdfPageEventHelper#onCloseDocument(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document) */ public void onCloseDocument(PdfWriter writer, Document document) &#123; // 7.最后一步了，就是关闭文档的时候，将模板替换成实际的 Y 值,至此，page x of y 制作完毕，完美兼容各种文档size。 total.beginText(); total.setFontAndSize(bf, presentFontSize);// 生成的模版的字体、颜色 String foot2 = \" \" + (writer.getPageNumber()) + \" 页\"; total.showText(foot2);// 模版显示的内容 total.endText(); total.closePath(); &#125;&#125; 添加书签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 添加分组标题(带标签) * @param document Document对象 * @param text 标题内容 * @param number 标题数字 * @param font 字体 * @return Chapter对象 */private Chapter addGroup(Document document, String text, int number, Font font) &#123; addTextLine(document, \"\", font); addTextLine(document, \"\", font); if (font != null) &#123; font.setSize(22f); font.setStyle(Font.BOLD); Paragraph paragraph = new Paragraph( (text == null ? \"\" : text), font); Chapter chapter = new Chapter(paragraph, number); chapter.setBookmarkOpen(true); chapter.setBookmarkTitle(number + \". \" + text); chapter.setTriggerNewPage(false); try &#123; document.add(chapter); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; return chapter; &#125; else &#123; Paragraph paragraph = new Paragraph((text == null ? \"\" : text)); Chapter chapter = new Chapter(paragraph, number); chapter.setBookmarkOpen(true); chapter.setBookmarkTitle(number + \". \" + text); chapter.setTriggerNewPage(false); try &#123; document.add(paragraph); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; return chapter; &#125;&#125; /** * 添加组内小标题(带标签) * * @param document Document对象 * @param chapter Chapter对象 * @param text 标题 * @param number 序号 * @param font 字体 */private void addGroupItem(Document document, Chapter chapter, String text, int groupNumber, int number, Font font) &#123; addTextLine(document, \"\", font); if (font != null) &#123; font.setSize(18f); font.setStyle(Font.BOLD); Paragraph paragraph = new Paragraph((text == null ? \"\" : text), font); Section section = chapter.addSection(paragraph); section.setBookmarkOpen(true); section.setBookmarkTitle(groupNumber + \".\" + number + \". \" + text); section.setTriggerNewPage(false); section.setNumberStyle(Section.NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT); try &#123; document.add(section); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; Paragraph paragraph = new Paragraph((text == null ? \"\" : text)); Section section = chapter.addSection(paragraph); section.setBookmarkOpen(true); section.setBookmarkTitle(groupNumber + \".\" + number + \". \" + text); section.setNumberStyle(Section.NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT); section.setTriggerNewPage(false); try &#123; document.add(section); &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125;&#125;"},{"title":"PHP-多文件上传接口实现","permalink":"http://zhouzhuo810.github.io/2017/08/10/PHP-多文件上传接口实现/","text":"想测试多文件上传功能； 使用PHP接口模拟一个接口非常方便； PHP多文件上传接收接口示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php //忽略警告 error_reporting(E_ALL || ~E_NOTICE); //设置编码 header(\"Content-type: text/html; charset=utf-8\"); /*设置时区*/ date_default_timezone_set('prc'); saveFiles(); $isError = false; function saveFiles() &#123; foreach ($_FILES as $name =&gt; $values) &#123; saveFile($name); &#125; if ($isError == false) &#123; echo '&#123;\"code\":\"successfully\", \"data\":&#123;\"msg\":\"上传成功！\"&#125;&#125;'; &#125; &#125; function saveFile($file) &#123; $allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\"); $temp = explode(\".\", $_FILES[$file][\"name\"]); $extension = end($temp); if ((($_FILES[$file][\"type\"] == \"image/gif\") || ($_FILES[$file][\"type\"] == \"image/jpeg\") || ($_FILES[$file][\"type\"] == \"image/jpg\") || ($_FILES[$file][\"type\"] == \"image/pjpeg\") || ($_FILES[$file][\"type\"] == \"image/x-png\") || ($_FILES[$file][\"type\"] == \"image/png\")) &amp;&amp; in_array($extension, $allowedExts)) &#123; if ($_FILES[$file][\"error\"] &gt; 0) &#123; $isError = true; echo '&#123;\"code\":\"fail\", \"data\":&#123;\"msg\":\"上传失败！\"&#125;&#125;'; break; &#125; else &#123; if (file_exists(\"image/\".$_FILES[$file][\"name\"])) &#123; &#125; else &#123; move_uploaded_file($_FILES[$file][\"tmp_name\"], \"image/\".$_FILES[$file][\"name\"]); &#125; &#125; &#125; else &#123; $isError = true; echo '&#123;\"code\":\"fail\", \"data\":&#123;\"msg\":\"非法文件格式！\"&#125;&#125;'; break; &#125; &#125; ?&gt;"},{"title":"Android常用代码-点击隐藏虚拟键盘","permalink":"http://zhouzhuo810.github.io/2017/08/10/Android常用功能-点击隐藏虚拟键盘/","text":"代码非常简单： 1234567view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; InputMethodManager imm = (InputMethodManager)v.getContext().getSystemService(INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(v.getWindowToken(), 0); &#125;&#125;);"},{"title":"Markdown-语法总结","permalink":"http://zhouzhuo810.github.io/2017/08/06/Markdown语法总结/","text":"[大标题] 语法： 1# 标题内容 [中标题] 语法： 1## 标题内容 [小标题] 语法： 1### 标题内容 [代码块] 语法： 123三个` 代码内容三个` [链接] 语法： 1[链接说明](链接地址) https://github.com/PhilJay/MPAndroidChart [图片] 语法： 1![图片说明](图片路径或地址)"},{"title":"SQL-快速将Excel的数据导入数据库","permalink":"http://zhouzhuo810.github.io/2017/07/28/SQL-快速将Excel的数据导入数据库/","text":"关键代码12=CONCATENATE(&quot;INSERT INTO TableName (Colomn1, Column2) values (&apos;&quot;&amp;A1&amp;&quot;&apos;,&apos;&quot;&amp;B1&amp;&quot;&apos;);&quot;)` 效果图"},{"title":"Android签名打包-获取Windows和Mac系统中调试证书和发布证书的SHA1","permalink":"http://zhouzhuo810.github.io/2017/07/28/Android签名打包-获取Mac调试证书的SHA1/","text":"发布证书 Windows和Mac一样 打开Android Studio 找到Terminal,studio下方 键入命令 1keytool -v -list -keystore keystorePath(例:e:\\test.keystore) 输入密钥库口令，即可查看相关信息 注意：如果命令不加-v 是没有MD5信息的 调试证书 Windows win+R cmd,回车 输入如下命令 (admin是电脑用户名)： 1keytool -v -list -keystore c:\\users\\admin\\.android\\debug.keystore -alias androiddebugkey -storepass android -keypass android Mac 打开Android Studio 进入Terminal 输入如下命令： 1keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android"},{"title":"Android疑难杂症-Glide加载圆角或圆形图片","permalink":"http://zhouzhuo810.github.io/2017/07/27/Android疑难杂症-Glide加载圆角或圆形图片/","text":"添加类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.RectF; import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation; public class GlideCircleTransform &#123; public static class GlideRoundTransform extends BitmapTransformation &#123; private float radius = 0f; public GlideRoundTransform(Context context) &#123; this(context, 6); &#125; public GlideRoundTransform(Context context, int dp) &#123; super(context); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return roundCrop(pool, toTransform); &#125; private Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName() + Math.round(radius); &#125; &#125;&#125; 使用方式12345Glide.with(context) .load(url) .transform(new CenterCrop(mContext), new GlideCircleTransform.GlideRoundTransform(mContext, 300)) .into(imageView);"},{"title":"Android签名打包-指定apk文件名","permalink":"http://zhouzhuo810.github.io/2017/07/27/Android签名打包-指定apk文件名/","text":"开发工具 Android Studio 操作方法在build.gradle中加入 1234567891011121314151617181920android &#123; //... applicationVariants.all &#123;variant -&gt; variant.outputs.each &#123;output -&gt; def outputFile = output.outputFile def fileName if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123; if (variant.buildType.name.equals(&apos;release&apos;)) &#123; fileName = &quot;APP名称_$&#123;defaultConfig.versionName&#125;_$&#123;defaultConfig.versionCode&#125;.apk&quot; &#125; else if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; fileName = &quot;APP名称_$&#123;defaultConfig.versionName&#125;_$&#123;defaultConfig.versionCode&#125;_debug.apk&quot; &#125; output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125;"},{"title":"JavaEE-SpringMVC之pom.xml","permalink":"http://zhouzhuo810.github.io/2017/07/20/JavaEE-SpringMVC之pom-xml/","text":"开发工具 InteliJ IDEA 新建一个maven工程复制如下依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 这个不要照抄 --&gt; &lt;groupId&gt;me.zhouzhuo810&lt;/groupId&gt; &lt;artifactId&gt;zzapidoc-maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- Nexus 私服配置 --&gt; &lt;!--&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;--&gt; &lt;developers&gt; &lt;developer&gt; &lt;id&gt;web&lt;/id&gt; &lt;name&gt;alexgaoyh&lt;/name&gt; &lt;email&gt;alexgaoyh@sina.com&lt;/email&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Quartz framework --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20140107&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.1.6.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.18.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;4.3.4.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt; &lt;version&gt;3.2.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-tools&lt;/artifactId&gt; &lt;version&gt;4.0.0-CR1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt; &lt;version&gt;4.1.6.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- emial support --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Shiro security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- end of Shiro security --&gt; &lt;!-- jstl jsp页面标签 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--打包时不包含--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--这里说明jsp-api.jar文件将由应用服务器提供，打包时不需要包含--&gt; &lt;/dependency&gt; &lt;!-- 测试使用，打包时不会打进去 --&gt; &lt;!-- Sprint-test 相关测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;3.2.11.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;web&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 这里的 tomcat7-maven-plugin 为使用插件部署Maven Web项目：--&gt; &lt;!-- 此处需要配置本地环境，tomcat: tomcat_user。xml，添加manager角色和用户，用于插件自动部署应用 --&gt; &lt;!-- 打开Maven： setting.xml，在&lt;servers&gt;节点下配置上面的相关Tomcat的Manager用户信息， --&gt; &lt;!-- 开启下面的插件配置代码段 --&gt; &lt;!-- tomcat7:deploy tomcat7:redeploy tomcat7:undeploy --&gt; &lt;!-- &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; tomcat管理路径 &lt;server&gt;Tomcat7&lt;/server&gt; 与settings.xml文件中Server的id相同 &lt;path&gt;/web&lt;/path&gt; 应用的部署位置 &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; --&gt; &lt;/build&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;/project&gt;"},{"title":"Android疑难杂症-EditText抢占焦点使ScrollView自动滑动问题","permalink":"http://zhouzhuo810.github.io/2017/07/18/Android疑难杂症-EditText抢占焦点使ScrollView自动滑动问题/","text":"解决方法： 重写ScrollView的这个方法： 1234@Overridepublic boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) &#123; return child instanceof EditText;&#125;"},{"title":"Swift开源控件-汇总","permalink":"http://zhouzhuo810.github.io/2017/06/29/Swift开源控件-汇总/","text":"1Github上的实用的Swift开源控件(后续看到再补充) 网络框架Alamofire 图片框架AlamofireImage 进度提示SwiftNotice JSON解析SwiftyJSON"},{"title":"Android自定义控件-CameraCardCrop","permalink":"http://zhouzhuo810.github.io/2017/06/22/Android自定义控件-CameraCardCrop/","text":"CameraCardCrop一个卡片（证件）拍照裁剪框架。(A cutting framework for card-photo.) Gradle1compile &apos;me.zhouzhuo810.cameracardcrop:camera-card-crop:1.0.2&apos; Screenshot Notice12345678910111213141516171819202122232425262728293031323334card---------------------| width || || |height| |---------------------phone------------------------------------| || || || || || mask || || width || ------------------------ || | | || | height | | screen height| | rect | || | | || ------------------------ || || || || || || screen width |-------------------------------------CameraConfig.RATIO_WIDTH = card&apos;s widthCameraConfig.RATIO_HEIGHT = card&apos;s heightCameraConfig.PERCENT_WIDTH = rect&apos;swidth / screen&apos;s width Usagestep 1. Add Activity in your AndroidManifest.xml file.1234&lt;activity android:name=\"me.zhouzhuo810.cameracardcrop.CropActivity\" android:screenOrientation=\"portrait\" android:theme=\"@style/Theme.AppCompat.NoActionBar\"&gt;&lt;/activity&gt; step 2. Add permissions in your AndroidManifest.xml file.123456&lt;uses-permission android:name=\"android.permission.CAMERA\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/&gt;&lt;uses-feature android:name=\"android.hardware.camera\" /&gt;&lt;uses-feature android:name=\"android.hardware.camera.autofocus\" /&gt; step 3. Example for use.1234567891011121314151617181920212223public void takePhoto(View v) &#123; Intent intent = new Intent(MainActivity.this, CropActivity.class); intent.putExtra(CameraConfig.RATIO_WIDTH, 855); intent.putExtra(CameraConfig.RATIO_HEIGHT, 541); intent.putExtra(CameraConfig.PERCENT_WIDTH, 0.8f); //[0,1] intent.putExtra(CameraConfig.MASK_COLOR, 0x2f000000); intent.putExtra(CameraConfig.RECT_CORNER_COLOR, 0xff00ff00); intent.putExtra(CameraConfig.TEXT_COLOR, 0xffffffff); intent.putExtra(CameraConfig.HINT_TEXT, \"请将方框对准证件拍照\"); intent.putExtra(CameraConfig.IMAGE_PATH, Environment.getExternalStorageDirectory().getAbsolutePath()+\"/CameraCardCrop/\"+System.currentTimeMillis()+\".jpg\"); startActivityForResult(intent, 0x01);&#125;@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK) &#123; if (requestCode == 0x01) &#123; String path = data.getStringExtra(CameraConfig.IMAGE_PATH); ivPic.setImageURI(Uri.parse(\"file://\"+path)); &#125; &#125;&#125;"},{"title":"Android开源控件-MPAndroidChart","permalink":"http://zhouzhuo810.github.io/2017/06/21/Android开源控件-MPAndroidChart/","text":"概述为什么要写这个小结？ MPAndroidChart文档是英文的，demo没有注释。 为了让以后使用MPAndroidChart更加方便。 MPAndroidChart简介项目地址https://github.com/PhilJay/MPAndroidChart 我用的版本1compile &apos;com.github.PhilJay:MPAndroidChart:v3.0.2&apos; 用法总结折线图/曲线图(LineChart) 初始化控件 12345678910111213141516171819202122//是否画背景线weekChart.setDrawGridBackground(false);//是否画边界weekChart.setDrawBorders(false);//是否画标记weekChart.setDrawMarkers(false);//是否画色标weekChart.getLegend().setEnabled(false);//是否显示描述weekChart.getDescription().setEnabled(false);//空数据提示文字weekChart.setNoDataText(getString(R.string.no_data));//横坐标的位置(上，下，或上和下)weekChart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);//是否画横坐标的线(竖线)weekChart.getXAxis().setDrawGridLines(false);//是否画右边的纵坐标weekChart.getAxisRight().setEnabled(false);//是否画左边的纵坐标的线weekChart.getAxisLeft().setDrawGridLines(false);//是否画左边的纵坐标weekChart.getAxisLeft().setDrawLabels(true); 让第一点和最后一点显示全 1234//设置最小X坐标小于0weekChart.getXAxis().setAxisMinimum(-0.5f);//设置最大X坐标大于 (点的数量-0.5)weekChart.getXAxis().setAxisMaximum(week.size()-0.5f); 设置X坐标不跳过或省略 12//设置X坐标个数，以保证X坐标都显示出来weekChart.getXAxis().setLabelCount(week.size()); 数据填充 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void updateWeek(final List&lt;GetDefectiveRateResult.DataEntity.WeekEntity&gt; week) &#123; if (week != null &amp;&amp; week.size() &gt; 0) &#123; //设置左右间距 weekChart.getXAxis().setAxisMinimum(-0.5f); weekChart.getXAxis().setAxisMaximum(week.size()-0.5f); //设置X坐标不省略 weekChart.getXAxis().setLabelCount(week.size()); //数据处理 List&lt;Entry&gt; values = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; week.size(); i++) &#123; GetDefectiveRateResult.DataEntity.WeekEntity weekEntity = week.get(i); values.add(new Entry(i, weekEntity.getValue())); &#125; //修改X坐标的值 weekChart.getXAxis().setValueFormatter(new IAxisValueFormatter() &#123; @Override public String getFormattedValue(float value, AxisBase axis) &#123; return week.get((int) value).getName(); &#125; &#125;); LineDataSet lineDataSet = new LineDataSet(values, \"周废品率(%)\"); //圆圈外圈的半径 lineDataSet.setCircleRadius(4f); //圆圈空心的半径 lineDataSet.setCircleHoleRadius(3f); //圆环的颜色 lineDataSet.setCircleColor(getResources().getColor(R.color.colorBarColor)); //折线或曲线的宽度 lineDataSet.setLineWidth(2f); //线的模式：决定是 折线还是曲线 lineDataSet.setMode(LineDataSet.Mode.CUBIC_BEZIER); //线的颜色 lineDataSet.setColor(getResources().getColor(R.color.colorBarColor)); //线下方是否填充颜色 lineDataSet.setDrawFilled(true); //设置线下方填充的颜色 if (Build.VERSION.SDK_INT &gt;= 18) &#123; lineDataSet.setFillDrawable(getResources().getDrawable(R.drawable.line_one_shape)); &#125; else &#123; lineDataSet.setFillColor(0x4f2F7EDB); &#125; LineData lineData = new LineData(lineDataSet); weekChart.setData(lineData); weekChart.invalidate(); &#125; else &#123; //没数据时清理图表 weekChart.clear(); &#125;&#125; line_one_shape.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;gradient android:startColor=\"#7f2F7EDB\" android:angle=\"270\" android:endColor=\"@android:color/transparent\"/&gt;&lt;/shape&gt; 饼状图(PieChart) 初始化控件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//空数据提示reasonPieChart.setNoDataText(getString(R.string.no_data));//使用百分比值画图(也就是说按数据的大小比例画图)reasonPieChart.setUsePercentValues(true);//描述reasonPieChart.getDescription().setEnabled(false);//饼状图的位置偏移reasonPieChart.setExtraOffsets(5, 10, 5, 5); //是否可以拖动旋转reasonPieChart.setRotationEnabled(true);//好像是拖动转圈后松手的惯性(0到1,越大越快)reasonPieChart.setDragDecelerationFrictionCoef(0.95f); //是否画中间的文字reasonPieChart.setDrawCenterText(true);//中间的文字reasonPieChart.setCenterText(\"原因废品率(%)\"); //是否画中间的洞reasonPieChart.setDrawHoleEnabled(true);//中间洞的颜色reasonPieChart.setHoleColor(Color.WHITE);//中间洞外边一小圈的颜色reasonPieChart.setTransparentCircleColor(Color.WHITE);//中间洞外边一小圈的透明度reasonPieChart.setTransparentCircleAlpha(110);//中间洞的半径reasonPieChart.setHoleRadius(48f);//洞外小圈的半径reasonPieChart.setTransparentCircleRadius(51f); //设置旋转的角度reasonPieChart.setRotationAngle(0); //是否画扇形内部的文字reasonPieChart.setDrawEntryLabels(false);//扇形内部文字的颜色reasonPieChart.setEntryLabelColor(Color.BLACK);//扇形内部文字的大小reasonPieChart.setEntryLabelTextSize(7f); //是否启用色标reasonPieChart.getLegend().setEnabled(true);Legend legend = reasonPieChart.getLegend();//色标的方面legend.setOrientation(Legend.LegendOrientation.VERTICAL);//色标的水平位置legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);//色标的垂直位置legend.setVerticalAlignment(Legend.LegendVerticalAlignment.CENTER);//色标画在图标外面还是里面legend.setDrawInside(false);//色标文字的大小legend.setTextSize(11f); 数据填充 1234567891011121314151617181920212223242526272829303132private void updateReason(final List&lt;GetDefectiveRateResult.DataEntity.ReasonEntity&gt; reason) &#123; if (reason != null &amp;&amp; reason.size() &gt; 0) &#123; List&lt;PieEntry&gt; yVals = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; reason.size(); i++) &#123; GetDefectiveRateResult.DataEntity.ReasonEntity reasonEntity = reason.get(i); //值和名称 PieEntry barEntry = new PieEntry(reasonEntity.getValue(), \"[\"+reasonEntity.getValue()+\"%] \"+reasonEntity.getName()); yVals.add(barEntry); &#125; PieDataSet set = new PieDataSet(yVals, \"\"); ArrayList&lt;Integer&gt; colors = new ArrayList&lt;&gt;(); //扇形的颜色 for (int vordiplomColor : ColorTemplate.VORDIPLOM_COLORS) &#123; colors.add(vordiplomColor); &#125; for (int libertyColor : ColorTemplate.LIBERTY_COLORS) &#123; colors.add(libertyColor); &#125; set.setColors(colors); //数值的的颜色 set.setValueTextColor(Color.BLACK); //分隔线的颜色 set.setValueLineColor(Color.WHITE); PieData barData = new PieData(set); //数值的大小 barData.setValueTextSize(7f); reasonPieChart.setData(barData); reasonPieChart.invalidate(); &#125; else &#123; reasonPieChart.clear(); &#125;&#125; 柱状图(BarChart/HorizontalBarChart) 初始化控件 123456789101112131415161718192021222324252627282930313233343536373839//是否画柱子的底色reasonBarChart.setDrawBarShadow(false);//是否画数字在柱子顶部reasonBarChart.setDrawValueAboveBar(true);//是否显示右下角的描述reasonBarChart.getDescription().setEnabled(false);//是否双向指缩放reasonBarChart.setPinchZoom(false);//是否画背景格子reasonBarChart.setDrawGridBackground(false);//是否显示右边的坐标reasonBarChart.getAxisRight().setEnabled(false);//x轴的位置(左边，右边，两边)reasonBarChart.getXAxis().setPosition(XAxis.XAxisPosition.BOTTOM);//是否显示X轴的坐标线reasonBarChart.getXAxis().setDrawGridLines(false);//设置X轴坐标的文字大小reasonBarChart.getXAxis().setTextSize(9f);//设置X轴坐标的旋转角度//reasonBarChart.getXAxis().setLabelRotationAngle(45);//是否显示左边Y轴的坐标线reasonBarChart.getAxisLeft().setDrawGridLines(false);//设置左边Y轴的最小值reasonBarChart.getAxisLeft().setAxisMinimum(0f);//设置左边Y轴的是否显示reasonBarChart.getAxisLeft().setEnabled(false);//色标Legend legend = reasonBarChart.getLegend();legend.setEnabled(false);legend.setOrientation(Legend.LegendOrientation.HORIZONTAL);legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);legend.setVerticalAlignment(Legend.LegendVerticalAlignment.CENTER);legend.setForm(Legend.LegendForm.SQUARE);legend.setFormSize(9f);legend.setXEntrySpace(4f);legend.setDrawInside(false);legend.setTextSize(11f); X轴坐标转换 123456productBarChart.getXAxis().setValueFormatter(new IAxisValueFormatter() &#123; @Override public String getFormattedValue(float value, AxisBase axis) &#123; return product.get((int) value).getName()+\" [\"+product.get((int) value).getValue()+\"%]\"; &#125;&#125;); 填充数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void updateProduct(final List&lt;GetDefectiveRateResult.DataEntity.ProductEntity&gt; product) &#123; if (product != null &amp;&amp; product.size() &gt; 0) &#123; //保证X坐标显示全 productBarChart.getXAxis().setLabelCount(product.size()); //调整显示顺序 Collections.reverse(product); //整理数据 List&lt;BarEntry&gt; yVals = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; product.size(); i++) &#123; GetDefectiveRateResult.DataEntity.ProductEntity productEntity = product.get(i); BarEntry barEntry = new BarEntry(i, productEntity.getValue()); yVals.add(barEntry); &#125; //X轴坐标转换 productBarChart.getXAxis().setValueFormatter(new IAxisValueFormatter() &#123; @Override public String getFormattedValue(float value, AxisBase axis) &#123; return product.get((int) value).getName()+\" [\"+product.get((int) value).getValue()+\"%]\"; &#125; &#125;); BarDataSet set = new BarDataSet(yVals, \"\"); //设置柱子颜色 ArrayList&lt;Integer&gt; colors = new ArrayList&lt;&gt;(); for (int joyfulColor : ColorTemplate.JOYFUL_COLORS) &#123; colors.add(joyfulColor); &#125; for (int colorfulColor : ColorTemplate.COLORFUL_COLORS) &#123; colors.add(colorfulColor); &#125; set.setColors(colors); //设置柱子上文字的颜色 set.setValueTextColor(Color.BLACK); //设置柱子上文字的值是否显示 set.setDrawValues(true); BarData barData = new BarData(set); //设置柱子上文字的大小 barData.setValueTextSize(7f); productBarChart.setData(barData); productBarChart.invalidate(); &#125; else &#123; productBarChart.clear(); &#125;&#125; 效果图"},{"title":"Android 6.0新特性-动态权限申请","permalink":"http://zhouzhuo810.github.io/2017/06/14/Android-6-0新特性-动态权限申请/","text":"Android 6.0之后，部分权限需要动态申请。但是AndroidManifest.xml文件中同样需要申明。 常见处理方式请求权限1234567891011121314if (Build.VERSION.SDK_INT &gt; 22) &#123; if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; if (!ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; Toast.makeText(MainActivity.this, \"这里提示用户进入设置界面开启权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //Request ActivityCompat.requestPermissions(MainActivity.this, new String[] &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 0x01); &#125; &#125; else &#123; //Allow... &#125; &#125; else &#123; //Allow... &#125; Activity必须implements ActivityCompat.OnRequestPermissionsResultCallback处理请求结果123456789101112131415@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 0x01) &#123; if (grantResults.length &gt; 0) &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(MainActivity.this, \"Allow\", Toast.LENGTH_SHORT).show(); //allow... &#125; else &#123; Toast.makeText(MainActivity.this, \"Deny\", Toast.LENGTH_SHORT).show(); //deny... &#125; &#125; &#125;&#125; 使用RxPermission(推荐)查看Github 使用AndPermission查看Github"},{"title":"Android 7.0新特性-FileUriExposedException","permalink":"http://zhouzhuo810.github.io/2017/06/14/Android-7-0新特性-FileUriExposedException/","text":"下面两个问题都是同一个错误FileUriExposedException。 问题1：App更新最近有客户反应App自动更新安装失败。查看原因报的是FileUriExposedException错误。 查看官网API找到了解决之法。 新建res/xml/provider_paths.xml文件1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;paths xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;external-path name=\"external_files\" path=\".\"/&gt;&lt;/paths&gt; 在AndroidManifest.xml中添加provider123456789&lt;provider android:name=\"android.support.v4.content.FileProvider\" android:authorities=\"您的包名.provider\" android:exported=\"false\" android:grantUriPermissions=\"true\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/provider_paths\"/&gt;&lt;/provider&gt; 修改Uri的获取方式123456789101112131415161718private void installApk(String fileName) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); if (Build.VERSION.SDK_INT &gt; 23) &#123; //FIX ME by ZZ : 7.0 Uri uri = FileProvider.getUriForFile(MainActivity.this, BuildConfig.APPLICATION_ID+\".provider\", new File(Constants.APK_DOWNLOAD_DIR + File.separator + fileName)); //这flag很关键 intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION|Intent.FLAG_GRANT_WRITE_URI_PERMISSION); intent.setDataAndType(uri, \"application/vnd.android.package-archive\"); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); this.startActivity(intent); &#125; else &#123; intent.setDataAndType(Uri.fromFile(new File(Constants.APK_DOWNLOAD_DIR + File.separator + fileName)), \"application/vnd.android.package-archive\"); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); this.startActivity(intent); &#125;&#125; 问题2：调用系统相机拍照解决方式1（1）前两个步骤同上 （2） 123456789101112131415161718private void takePhoto() &#123; File file = new File(PATH); if (!file.isDirectory()) &#123; file.mkdirs(); &#125; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); Uri uri; if (Build.VERSION.SDK_INT &gt; 23) &#123; uri = FileProvider.getUriForFile(MainActivity.this, BuildConfig.APPLICATION_ID+\".provider\", new File(PATH+NAME)); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION|Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; else &#123; uri = Uri.fromFile(new File(PATH+NAME)); &#125; intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, 0x01);&#125; 注意别漏了这句: 1intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION|Intent.FLAG_GRANT_WRITE_URI_PERMISSION); 解决方式21234567891011121314151617181920212223private void takePhoto() &#123; final File file = new File(Constants.PIC_UPLOAD_ROOT_PATH); if (!file.isDirectory()) &#123; file.mkdirs(); &#125; Intent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//构造intent Uri uri; String pathOne = Constants.PIC_UPLOAD_ROOT_PATH + System.currentTimeMillis() + \".jpg\"; AbSharedUtil.putString(this, Constants.PUT_FILE_ONE, pathOne); final File fileOne = new File(pathOne); if (Build.VERSION.SDK_INT&lt;24)&#123; uri = Uri.fromFile(fileOne); &#125;else &#123; ContentValues contentValues = new ContentValues(1); contentValues.put(MediaStore.Images.Media.DATA, fileOne.getAbsolutePath()); uri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,contentValues); &#125; if (fileOne.exists()) &#123; fileOne.delete(); &#125; cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(cameraIntent, CAMERA_REQUEST_ONE);//发出intent，并要求返回调用结果&#125;"},{"title":"Android自定义控件-ZzExcelCreator","permalink":"http://zhouzhuo810.github.io/2017/06/14/Android自定义控件-ZzExcelCreator/","text":"ZzExcelCreatorExcel表格生成工具 项目地址:https://github.com/zhouzhuo810/ZzExcelCreator（欢迎star!） 效果图： 最近做项目用到jxl.jar来生成Excel表格； 但是发现jxl源码都没有注释的，方法也没有说明，虽然最后在网上找到了对应的方法。 不过这不是我的style，果断自己封装一下，添加注释。 下面介绍一下用法： Gradle：1compile &apos;me.zhouzhuo.zzexcelcreator:zz-excel-creator:1.0.0&apos; 创建Excel文件和工作表12345ZzExcelCreator .getInstance() .createExcel(PATH, params[0]) //生成excel文件 .createSheet(params[1]) //生成sheet工作表 .close(); 打开Excel文件和工作表123456ZzExcelCreator .getInstance() .openExcel(new File(PATH + fileName + \".xls\")) //打开Excel文件 .openSheet(0) //打开Sheet工作表 ... ... .close(); 设置单元格内容格式：12345678//设置单元格内容格式WritableCellFormat format = ZzFormatCreator .getInstance() .createCellFont(WritableFont.ARIAL) //设置字体 .setAlignment(Alignment.CENTRE, VerticalAlignment.CENTRE) //设置对齐方式(水平和垂直) .setFontSize(14) //设置字体大小 .setFontColor(Colour.ROSE) //设置字体颜色 .getCellFormat(); 设置行高、列宽和写入字符串或数字123456789ZzExcelCreator .getInstance() .openExcel(new File(PATH + fileName + \".xls\")) .openSheet(0) .setColumnWidth(Integer.parseInt(col), 25) //设置列宽 .setRowHeight(Integer.parseInt(row), 400) //设置行高 .fillContent(Integer.parseInt(col), Integer.parseInt(row), str, format) //填入字符串 .fillNumber(Integer.parseInt(col), Integer.parseInt(row), Double.parseDouble(str), format) //填入数字 .close(); 最后就是，这些操作最好在子线程操作。"},{"title":"Android自定义控件-ZzImageBox","permalink":"http://zhouzhuo810.github.io/2017/06/14/Android自定义控件-ZzImageBox/","text":"ZzImageBoxA powerful image container for adding and removing images. 功能简介：1.支持添加、删除、默认图片的配置； 2.支持最大行数限制； 3.支持每行数量修改； 4.支持添加、删除、图片点击回调接口。 5.支持Box的添加(.addImage(String imagePath))和删除(.removeImage(int position))； 6.支持加载本地图片(使用方法.addImage(String imagePath))； 7.支持左右margin设置。 Gradle1compile &apos;me.zhouzhuo.zzimagebox:zz-image-box:1.0.4&apos; Maven123456&lt;dependency&gt; &lt;groupId&gt;me.zhouzhuo.zzimagebox&lt;/groupId&gt; &lt;artifactId&gt;zz-image-box&lt;/artifactId&gt; &lt;version&gt;1.0.4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; What does it look like? How to use it ?xml: 1234567891011121314&lt;me.zhouzhuo.zzimagebox.ZzImageBox android:id=\"@+id/zz_image_box\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:zib_left_margin=\"20dp\" app:zib_right_margin=\"20dp\" app:zib_img_padding=\"5dp\" app:zib_img_size_one_line=\"4\" app:zib_max_line=\"3\" app:zib_img_deletable=\"true\" app:zib_img_add=\"@drawable/iv_add\" app:zib_img_default=\"@drawable/iv_default\" app:zib_img_delete=\"@drawable/iv_delete\" /&gt; java: 123456789101112131415161718192021final ZzImageBox imageBox = (ZzImageBox) findViewById(R.id.zz_image_box);imageBox.setOnImageClickListener(new ZzImageBox.OnImageClickListener() &#123; @Override public void onImageClick(int position, String filePath) &#123; Log.d(\"ZzImageBox\", \"image clicked:\" + position + \",\" + filePath); &#125; @Override public void onDeleteClick(int position, String filePath) &#123; imageBox.removeImage(position); Log.d(\"ZzImageBox\", \"delete clicked:\" + position + \",\" + filePath); Log.d(\"ZzImageBox\", \"all images\\n\"+imageBox.getAllImages().toString()); &#125; @Override public void onAddClick() &#123; imageBox.addImage(null); Log.d(\"ZzImageBox\", \"add clicked\"); Log.d(\"ZzImageBox\", \"all images\\n\"+imageBox.getAllImages().toString()); &#125;&#125;); 属性说明：1234567891011&lt;declare-styleable name=&quot;ZzImageBox&quot;&gt; &lt;attr name=&quot;zib_max_line&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;zib_img_size_one_line&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;zib_img_padding&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;zib_img_default&quot; format=&quot;color|reference&quot; /&gt; &lt;attr name=&quot;zib_img_delete&quot; format=&quot;color|reference&quot; /&gt; &lt;attr name=&quot;zib_img_add&quot; format=&quot;color|reference&quot; /&gt; &lt;attr name=&quot;zib_img_deletable&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;zib_left_margin&quot; format=&quot;dimension|reference&quot; /&gt; &lt;attr name=&quot;zib_right_margin&quot; format=&quot;dimension|reference&quot; /&gt;&lt;/declare-styleable&gt; 属性名 属性类型 属性功能 zib_max_line integer 最大行数 zib_img_size_one_line integer 每行数量 zib_img_padding dimension 图片之间的间距 zib_img_default drawable color 默认图片资源id zib_img_delete drawable color 删除图片资源id zib_img_add drawable color 添加图片资源id zib_img_deletable boolean 是否显示删除图片 zib_left_margin dimension 控件距离屏幕左边距离 zib_right_margin dimension 控件距离屏幕右边距离"},{"title":"Android自定义控件-ZzWeatherView","permalink":"http://zhouzhuo810.github.io/2017/06/14/Android自定义控件-ZzWeatherView/","text":"ZzWeatherView一个现实天气的控件 Gradle1compile &apos;me.zhouzhuo.zzweatherview:zz-weather-view:1.0.2&apos; 效果图如下： 用法简介1）布局 drawable/scroll_bar_thumb.xml123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;gradient android:startColor=\"#33999999\" android:endColor=\"#80aaaaaa\" android:angle=\"0\"/&gt; &lt;corners android:radius=\"6dp\" /&gt;&lt;/shape&gt; 12345678910&lt;me.zhouzhuo.zzweatherview.ZzWeatherView android:id=\"@+id/weather_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:scrollbarThumbHorizontal=\"@drawable/scroll_bar_thumb\" android:scrollbarTrackHorizontal=\"@drawable/scroll_bar_thumb\" android:scrollbarSize=\"4dp\" android:background=\"#333\" &gt;&lt;/me.zhouzhuo.zzweatherview.ZzWeatherView&gt; 2）java 1234567891011121314151617181920212223242526272829303132ZzWeatherView weatherView = (ZzWeatherView) findViewById(R.id.weather_view); //填充天气数据weatherView.setList(generateData()); //画折线weatherView.setLineType(ZzWeatherView.LINE_TYPE_DISCOUNT);//画曲线(不够圆滑希望有更好的建议联系我(Email:admin@zhouzhuo810.me))//weatherView.setLineType(ZzWeatherView.LINE_TYPE_CURVE); //设置线宽weatherView.setLineWidth(6f); //设置一屏幕显示几列(最少3列)try &#123; weatherView.setColumnNumber(5);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; //设置白天和晚上线条的颜色weatherView.setDayAndNightLineColor(Color.BLUE, Color.RED); //点击某一列weatherView.setOnWeatherItemClickListener(new ZzWeatherView.OnWeatherItemClickListener() &#123; @Override public void onItemClick(WeatherItemView itemView, int position, WeatherModel weatherModel) &#123; Toast.makeText(MainActivity.this, position+\"\", Toast.LENGTH_SHORT).show(); &#125;&#125;); 1234567891011 //数据源 WeatherModel model = new WeatherModel(); model.setDate(\"12/07\");//日期 model.setWeek(\"昨天\"); //星期 model.setDayWeather(\"大雪\"); //白天天气 model.setDayTemp(11); //白天温度 model.setNightTemp(5); //夜晚温度 model.setNightWeather(\"晴\"); //夜晚天气 model.setWindOrientation(\"西南风\"); //风向 model.setWindLevel(\"3级\"); // model.setAirLevel(AirLevel.EXCELLENT); //空气质量 更新日志v 1.0.2 添加设置曲线颜色方法； 添加设置列的数量方法； v 1.0.1 修复曲线不圆滑问题；"},{"title":"Android疑难杂症-自定义ViewGroup添加TextView的Gravity失效","permalink":"http://zhouzhuo810.github.io/2017/06/13/Android疑难杂症-自定义ViewGroup添加TextView的Gravity失效/","text":"解决方法： 在addView()之前 添加如下代码 12mTextView.measure(View.MeasureSpec.makeMeasureSpec(mWidth, View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(mHeight, View.MeasureSpec.EXACTLY));"},{"title":"IOS-pod的安装和使用","permalink":"http://zhouzhuo810.github.io/2017/06/08/IOS-pod的安装和使用/","text":"使用pod可以很方便的集成第三方框架。 安装1sudo gem install cocoapods 输入密码 等待即可。 完成标识如下： 1xx gems installed 验证安装是否成功1pod --help 切换目录切换到目标工程文件夹 1cd xxx 1pod init 1ls -al 会发现多了一个Podfile文件 编辑Podfile文件1vi Podfile 点击i进入编辑模式 移动光标，在需要的位置添加内容下面以SDWebImage为例： 123platform :ios, &apos;8.0&apos;pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos;use_frameworks! 点击esc 点击shift+； 输入wq，回车 安装包先关闭xcode 1pod install 注意会发现多了一个workspace的工程 如果以后要用集成了POD的工程的话就要用workspace的工程。 打开工程使用这个。"},{"title":"ACM-单词拼接问题","permalink":"http://zhouzhuo810.github.io/2017/06/08/ACM-单词拼接问题/","text":"描述 给你一些单词，请你判断能否把它们首尾串起来串成一串。 前一个单词的结尾应该与下一个单词的道字母相同。 输入 第一行是一个整数N(0&lt;N&lt;20)，表示测试数据的组数每组测试数据的第一行是一个整数M,表示该组测试数据中有M(2&lt;M&lt;1000)个互不相同的单词，随后的M行，每行是一个长度不超过30的单词,单词全部由小写字母组成。 输出 如果存在拼接方案，请输出所有拼接方案中字典序最小的方案。(两个单词之间输出一个英文句号”.”)如果不存在拼接方案，则输出 1*** 样例输入 12345678910111226alohaarachniddoggopherrattiger3oakmapleelm 样例输出 12aloha.arachnid.dog.gopher.rat.tiger*** 参考答案Java版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import java.util.PriorityQueue;import java.util.Queue;import java.util.Scanner;import java.util.Stack;//欧拉通路(路径) 只有一个点的入度比出度小一, 一个点的出度比入度大一 其余点的入度与出度相等//欧拉回路 所有点的入度与出度相等//并查集判断连通性 只有一个点的父节点是他本身//消圈算法遍历结果 class Node &#123; Queue&lt;String&gt; queue = new PriorityQueue&lt;String&gt;();// 首字母相同的单词可能有多个&#125; public class Main &#123; public static final int LEN = 26; private int start; private int[] father, num, inDegree, outDegree; private Node[] nodes; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t, n; Main main; String str; Node[] nodes = new Node[LEN]; for (int i = 0; i &lt; LEN; i++) &#123; nodes[i] = new Node(); &#125; t = sc.nextInt(); while (t-- != 0) &#123; n = sc.nextInt(); for (int i = 0; i &lt; n; i++) &#123; str = sc.next(); nodes[str.charAt(0) - 'a'].queue.add(str);// 单词首字母 &#125; main = new Main(nodes); main.execute(); for (int i = 0; i &lt; LEN; i++) &#123; nodes[i].queue.clear(); &#125; &#125; sc.close(); &#125; public Main(Node[] nodes) &#123; this.nodes = nodes; father = new int[LEN]; num = new int[LEN]; inDegree = new int[LEN]; outDegree = new int[LEN]; for (int i = 0; i &lt; LEN; i++) &#123; father[i] = i; num[i] = 1; &#125; for (int i = 0, start, end; i &lt; LEN; i++) &#123; for (String str : nodes[i].queue) &#123; start = str.charAt(0) - 'a';// 单词首 end = str.charAt(str.length() - 1) - 'a';// 单词尾 inDegree[end]++; outDegree[start]++; start = find(start); end = find(end); if (start != end) &#123; union(start, end); &#125; &#125; &#125; &#125; private int find(int i) &#123; return i == father[i] ? i : find(father[i]); &#125; private void union(int i, int j) &#123; father[i] = j; &#125; private boolean isEularRoute() &#123; start = -1; int count = 0; boolean find = false; for (int i = 0; i &lt; LEN; i++) &#123; if (inDegree[i] != outDegree[i]) &#123; if (Math.abs(inDegree[i] - outDegree[i]) != 1) return false; if (!find &amp;&amp; inDegree[i] &lt; outDegree[i]) &#123; find = true; start = i; &#125; if (++count &gt; 2) return false; &#125; else if (outDegree[i] &gt; 0 &amp;&amp; start == -1) &#123; start = i; &#125; &#125; return true; &#125; private boolean isConnected() &#123; for (int i = 0, count = 0; i &lt; LEN; i++) &#123; if (outDegree[i] &gt; 0 &amp;&amp; father[i] == i) &#123; if (++count &gt; 1) &#123; return false; &#125; &#125; &#125; return true; &#125; private void printResult(int i) &#123; dfs(i); if (!stack.isEmpty()) System.out.print(stack.pop()); while (!stack.isEmpty()) &#123; System.out.print(\".\" + stack.pop()); &#125; System.out.println(); &#125; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); private void dfs(int i) &#123; while (!nodes[i].queue.isEmpty()) &#123; String str = nodes[i].queue.poll(); dfs(str.charAt(str.length() - 1) - 'a'); stack.push(str); &#125; &#125; public void execute() &#123; if (!isConnected() || !isEularRoute()) &#123; System.out.println(\"***\"); return; &#125; printResult(start); &#125;&#125; /** * 欧拉回路:若图G中存在这样一条路径，使得它恰通过G中每条边一次，则称该路径为欧拉路径。若该路径是一个圈， 则成为欧拉回路。 * 具有欧拉回路的图成为欧拉图，具有欧拉路径但不具有欧拉回路的图成为半欧拉图。 1.无向连通图G是欧拉图，当且仅当G不含奇数度结点(G的所有结点度数为偶数)； * 2.无向连通图G含有欧拉通路，当且仅当G有零个或两个奇数度的结点； 3.有向连通图D是欧拉图，当且仅当该图为连通图且D中每个结点的入度=出度 * 4.有向连通图D含有欧拉通路，当且仅当该图为连通图且D中除两个结点外， 其余每个结点的入度=出度，且此两点满足deg－(u)－deg+(v)=±1。 * （起始点s的入度=出度-1，结束点t的出度=入度-1 或两个点的入度=出度） * * 连通图：若图中任意两点都是连通的，则该图是连通图。 */"},{"title":"ACM-(复杂排序问题)","permalink":"http://zhouzhuo810.github.io/2017/06/07/ACM-复杂排序问题/","text":"描述 现在有很多长方形，每一个长方形都有一个编号，这个编号可以重复；还知道这个长方形的宽和长，编号、长、宽都是整数；现在要求按照一下方式排序（默认排序规则都是从小到大）； 1.按照编号从小到大排序 2.对于编号相等的长方形，按照长方形的长排序； 3.如果编号和长都相同，按照长方形的宽排序； 4.如果编号、长、宽都相同，就只保留一个长方形用于排序,删除多余的长方形；最后排好序按照指定格式显示所有的长方形； 输入 第一行有一个整数 0&lt;n&lt;10000,表示接下来有n组测试数据；每一组第一行有一个整数 0&lt;m&lt;1000，表示有m个长方形；接下来的m行，每一行有三个数 ，第一个数表示长方形的编号， 第二个和第三个数值大的表示长，数值小的表示宽，相等说明这是一个正方形（数据约定长宽与编号都小于10000）； 输出 顺序输出每组数据的所有符合条件的长方形的 编号 长 宽 样例输入 12345678910181 1 11 1 11 1 21 2 11 2 22 1 12 1 22 2 1 样例输出 123451 1 11 2 11 2 22 1 12 2 1 参考答案Java版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); StringBuilder result = new StringBuilder(); for (int i=0; i&lt;n; i++) &#123; List&lt;Rect&gt; list = new ArrayList&lt;Rect&gt;(); int m = sc.nextInt(); for (int j=0; j&lt;m; j++) &#123; int no = sc.nextInt(); int a = sc.nextInt(); int b = sc.nextInt(); Rect r = new Rect(no, a&gt;b?a:b, a&lt;b?a:b); if (!isExist(list,r)) &#123; list.add(r); &#125; &#125; Collections.sort(list, new Comparator&lt;Rect&gt;()&#123; @Override public int compare(Rect r1, Rect r2) &#123; if (r1.no != r2.no) &#123; return r1.no &gt; r2.no ? 1 : -1; &#125; else &#123; if (r1.a != r2.a) &#123; return r1.a &gt; r2.a ? 1: -1; &#125; else &#123; return r1.b &gt; r2.b ? 1 : -1; &#125; else &#123; return 0; &#125; &#125; &#125; &#125;); for(int j=0 ; j&lt;list.size(); j++) &#123; result.append(list.get(j).toString()).append(\"\\n\"); &#125; &#125; System.out.println(result.toString()); &#125; public static boolean isExist(List&lt;Rect&gt; list, Rect r) &#123; for (int i=0; i&lt;list.size(); i++) &#123; Rect r1 = list.get(i); if (r1.no == r.no &amp;&amp; r1.a==r.a &amp;&amp; r1.b == r.b) &#123; return true; &#125; &#125; return false; &#125; public static class Rect &#123; public int no; public int a; public int b; public Rect(int no, int a, int b) &#123; this.no = no; this.a = a; this.b = b; &#125; public String toString() &#123; return no + \" \" + a +\" \" + b ; &#125; &#125;&#125;"},{"title":"ACM-(奇偶分离问题)","permalink":"http://zhouzhuo810.github.io/2017/06/07/ACM-奇偶分离问题/","text":"描述 有一个整型偶数n(2&lt;= n &lt;=10000),你要做的是：先把1到n中的所有奇数从小到大输出，再把所有的偶数从小到大输出。 输入 第一行有一个整数i（2&lt;=i&lt;30)表示有 i 组测试数据；每组有一个整型偶数n。 输出 第一行输出所有的奇数第二行输出所有的偶数 样例输入 12321014 样例输出 123451 3 5 7 9 2 4 6 8 10 1 3 5 7 9 11 13 2 4 6 8 10 12 14 参考答案Java版123456789101112131415161718192021222324252627282930import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int count = sc.nextInt(); String[] result = new String[count]; for(int i=0; i&lt;count; i++) &#123; int n = sc.nextInt(); StringBuilder sbj = new StringBuilder(); StringBuilder sbo = new StringBuilder(); for (int j=1; j&lt;=n; j++) &#123; if (isOval(j)) &#123; sbo.append(j).append(\" \"); &#125; else &#123; sbj.append(j).append(\" \"); &#125; &#125; result[i] = sbj.toString()+\"\\n\"+sbo.toString(); &#125; for (int i=0; i&lt;count; i++) &#123; System.out.println(result[i]); &#125; &#125; public static boolean isOval(int i) &#123; return i%2==0; &#125;&#125;"},{"title":"ACM-(素数求和问题)","permalink":"http://zhouzhuo810.github.io/2017/06/07/ACM-素数求和问题/","text":"描述 现在给你N个数（0&lt;N&lt;1000），现在要求你写出一个程序，找出这N个数中的所有素数，并求和。 输入 第一行给出整数M(0&lt;M&lt;10)代表多少组测试数据每组测试数据第一行给你N，代表该组测试数据的数量。接下来的N个数为要测试的数据，每个数小于1000 输出 每组测试数据结果占一行，输出给出的测试数据的所有素数和 样例输入 1234567351 2 3 4 5811 12 13 14 15 16 17 181021 22 23 24 25 26 27 28 29 30 样例输出 123104152 参考答案Java版1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int zu = sc.nextInt(); int[] sum = new int[zu]; for(int i=0; i&lt;zu; i++) &#123; int count = sc.nextInt(); int s = 0; for(int j=0; j&lt;count; j++) &#123; int value = sc.nextInt(); if (isPrime(value)) &#123; s += value; &#125; &#125; sum[i] = s; &#125; for(int i=0; i&lt;zu; i++) &#123; System.out.println(sum[i]); &#125; &#125; public static boolean isPrime(int a) &#123; boolean flag = true; if (a &lt; 2) &#123;// 素数不小于2 return false; &#125; else &#123; for (int i = 2; i &lt;= Math.sqrt(a); i++) &#123; if (a % i == 0) &#123;// 若能被整除，则说明不是素数，返回false flag = false; break;// 跳出循环 &#125; &#125; &#125; return flag; &#125; &#125;"},{"title":"ACM-(括号配对问题)","permalink":"http://zhouzhuo810.github.io/2017/06/07/ACM-括号配对问题/","text":"描述 现在，有一行括号序列，请你检查这行括号是否配对。 输入 第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有”[“,”]”,”(“,”)”四种字符 输出 每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 样例输入12343[(])(])([[]()]) 样例输出123NoNoYes 参考答案Java版12345678910111213141516171819202122232425262728293031323334353637import java.io.*;import java.util.*;public class Main &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); int count= sc.nextInt(); String[] strs = new String[count]; for(int i=0; i&lt;count; i++) &#123; strs[i] = sc.next(); &#125; Stack&lt;Character&gt; stack = null; for(int j=0; j&lt;count; j++) &#123; String str = strs[j]; if(str.length() % 2 == 1)&#123; System.out.println(\"No\"); &#125;else&#123; stack = new Stack&lt;Character&gt;(); for(int i=0;i&lt;str.length();i++)&#123; if(stack.isEmpty())&#123; stack.push(str.charAt(i)); &#125;else if(stack.peek() == '[' &amp;&amp; str.charAt(i) == ']' || stack.peek() == '(' &amp;&amp; str.charAt(i) == ')')&#123; stack.pop(); &#125;else&#123; stack.push(str.charAt(i)); &#125; &#125; if(stack.isEmpty())&#123; //如果栈是空的，说明括号匹配 System.out.println(\"Yes\"); &#125;else&#123; //说明栈不为空，括号不匹配 System.out.println(\"No\"); &#125; &#125; &#125; &#125;&#125;"},{"title":"ACM-(A+B问题)","permalink":"http://zhouzhuo810.github.io/2017/06/07/ACM-A-B问题/","text":"描述 此题为练手用题，请大家计算一下a+b的值. 输入 输入两个数，a,b 输出 输出a+b的值 样例输入 12 3 样例输出 15 参考答案C语言版1234567#include&lt;stdio.h&gt;int main()&#123;int a,b;scanf(\"%d%d\",&amp;a,&amp;b);printf(\"%d\\n\",a+b);&#125; Java版1234567891011import java.io.*;import java.util.*;public class Main&#123;public static void main(String args[]) throws Exception&#123;Scanner cin=new Scanner(System.in);int a=cin.nextInt(),b=cin.nextInt();System.out.println(a+b);&#125;&#125;"},{"title":"Swift笔记-访问控制","permalink":"http://zhouzhuo810.github.io/2017/06/07/Swift笔记-访问控制/","text":"访问控制可以限定其他源文件或模块中代码对你代码的访问级别。 Swift 为代码中的实体提供了四种不同的访问级别:public、internal、fileprivate、private。 访问级别 定义 public 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体。 internal 可以访问自己模块中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。 fileprivate 文件内私有，只能在当前源文件中使用。 private 只能在类中访问，离开了这个类或者结构体的作用域外面就无法访问。 语法123456789public class SomePublicClass &#123;&#125;internal class SomeInternalClass &#123;&#125;fileprivate class SomeFilePrivateClass &#123;&#125;private class SomePrivateClass &#123;&#125; public var somePublicVariable = 0internal let someInternalConstant = 0fileprivate func someFilePrivateFunction() &#123;&#125;private func somePrivateFunction() &#123;&#125; 除非有特殊的说明，否则实体都使用默认的访问级别 internal。 函数类型访问权限123func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // 函数实现&#125; 枚举类型访问权限枚举中成员的访问级别继承自该枚举，你不能为枚举中的成员单独申明不同的访问级别。 枚举 Student 被明确的申明为 public 级别，那么它的成员 Name，Mark 的访问级别同样也是 public： 1234567891011121314public enum Student &#123; case Name(String) case Mark(Int,Int,Int)&#125; var studDetails = Student.Name(\"Swift\")var studMarks = Student.Mark(98,97,95) switch studMarks &#123;case .Name(let studName): print(\"学生名: \\(studName).\")case .Mark(let Mark1, let Mark2, let Mark3): print(\"学生成绩: \\(Mark1),\\(Mark2),\\(Mark3)\")&#125; 子类访问权限子类的访问级别不得高于父类的访问级别。 123456789101112131415161718public class SuperClass &#123; fileprivate func show() &#123; print(\"超类\") &#125;&#125; // 访问级别不能低于超类 internal &gt; publicinternal class SubClass: SuperClass &#123; override internal func show() &#123; print(\"子类\") &#125;&#125; let sup = SuperClass()sup.show() let sub = SubClass()sub.show() 常量、变量、属性、下标访问权限==常量、变量、属性不能拥有比它们的类型更高的访问级别==。 如果常量、变量、属性、下标索引的定义类型是private级别的，那么它们必须要明确的申明访问级别为private: 1private var privateInstance = SomePrivateClass() Getter 和 Setter访问权限常量、变量、属性、下标索引的Getters和Setters的访问级别继承自它们所属成员的访问级别。 Setter的访问级别可以低于对应的Getter的访问级别，这样就可以控制变量、属性或下标索引的读写权限。 12345678910111213141516class Samplepgm &#123; fileprivate var counter: Int = 0&#123; willSet(newTotal)&#123; print(\"计数器: \\(newTotal)\") &#125; didSet&#123; if counter &gt; oldValue &#123; print(\"新增加数量 \\(counter - oldValue)\") &#125; &#125; &#125;&#125; let NewCounter = Samplepgm()NewCounter.counter = 100NewCounter.counter = 800 构造器和默认构造器访问权限我们可以给自定义的初始化方法申明访问级别，但是要不高于它所属类的访问级别。 如同函数或方法参数，初始化方法参数的访问级别也不能低于初始化方法的访问级别。 默认初始化方法的访问级别与所属类型的访问级别相同。 协议访问权限如果你定义了一个public访问级别的协议，那么实现该协议提供的必要函数也会是public的访问级别。 123456789101112131415161718192021222324252627282930public protocol TcpProtocol &#123; init(no1: Int)&#125; public class MainClass &#123; var no1: Int // local storage init(no1: Int) &#123; self.no1 = no1 // initialization &#125;&#125; class SubClass: MainClass, TcpProtocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // Requires only one parameter for convenient method required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125; let res = MainClass(no1: 20)let show = SubClass(no1: 30, no2: 50) print(\"res is: \\(res.no1)\")print(\"res is: \\(show.no1)\")print(\"res is: \\(show.no2)\") 扩展访问权限你可以在条件允许的情况下对类、结构体、枚举进行扩展。 泛型访问权限泛型类型或泛型函数的访问级别取泛型类型、函数本身、泛型类型参数三者中的最低访问级别。 123456789101112131415161718192021222324public struct TOS&lt;T&gt; &#123; var items = [T]() private mutating func push(item: T) &#123; items.append(item) &#125; mutating func pop() -&gt; T &#123; return items.removeLast() &#125;&#125; var tos = TOS&lt;String&gt;()tos.push(\"Swift\")print(tos.items) tos.push(\"泛型\")print(tos.items) tos.push(\"类型参数\")print(tos.items) tos.push(\"类型参数名\")print(tos.items)let deletetos = tos.pop() 类型别名任何你定义的类型别名都会被当作不同的类型，以便于进行访问控制。一个类型别名的访问级别不可高于原类型的访问级别。"},{"title":"Swift笔记-泛型","permalink":"http://zhouzhuo810.github.io/2017/06/07/Swift笔记-泛型/","text":"Swift 提供了泛型让你写出灵活且可重用的函数和类型。Swift 标准库是通过泛型代码构建出来的。Swift 的数组和字典类型都是泛型集。 泛型使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。 语法1func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) 实例1234567891011121314151617181920// 定义一个交换两个变量的函数func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let temporaryA = a a = b b = temporaryA&#125; var numb1 = 100var numb2 = 200 print(\"交换前数据: \\(numb1) 和 \\(numb2)\")swapTwoValues(&amp;numb1, &amp;numb2)print(\"交换后数据: \\(numb1) 和 \\(numb2)\") var str1 = \"A\"var str2 = \"B\" print(\"交换前数据: \\(str1) 和 \\(str2)\")swapTwoValues(&amp;str1, &amp;str2)print(\"交换后数据: \\(str1) 和 \\(str2)\") 泛型类型Swift 允许你定义你自己的泛型类型。 123456789101112131415161718192021222324struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125; var stackOfStrings = Stack&lt;String&gt;()print(\"字符串元素入栈: \")stackOfStrings.push(\"google\")stackOfStrings.push(\"runoob\")print(stackOfStrings.items); let deletetos = stackOfStrings.pop()print(\"出栈元素: \" + deletetos) var stackOfInts = Stack&lt;Int&gt;()print(\"整数元素入栈: \")stackOfInts.push(1)stackOfInts.push(2)print(stackOfInts.items); 扩展泛型类型当你扩展一个泛型类型的时候（使用 extension 关键字），你并不需要在扩展的定义中提供类型参数列表。 1234567891011121314151617181920212223242526struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125; extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125; var stackOfStrings = Stack&lt;String&gt;()print(\"字符串元素入栈: \")stackOfStrings.push(\"google\")stackOfStrings.push(\"runoob\") if let topItem = stackOfStrings.topItem &#123; print(\"栈中的顶部元素是：\\(topItem).\")&#125; print(stackOfStrings.items) 类型约束类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。 类型约束语法123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // 这里是泛型函数的函数体部分&#125; 上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。 实例12345678910111213141516// 非泛型函数，查找指定字符串在数组中的索引func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; // 找到返回索引值 return index &#125; &#125; return nil&#125; let strings = [\"google\", \"weibo\", \"taobao\", \"runoob\", \"facebook\"]if let foundIndex = findIndex(ofString: \"runoob\", in: strings) &#123; print(\"runoob 的索引为 \\(foundIndex)\")&#125; 关联类Swift 中使用 associatedtype 关键字来设置关联类型实例。 1234567891011121314151617181920212223242526272829303132333435363738394041// Container 协议protocol Container &#123; associatedtype ItemType // 添加一个新元素到容器里 mutating func append(_ item: ItemType) // 获取容器中元素的数 var count: Int &#123; get &#125; // 通过索引值类型为 Int 的下标检索到容器中的每一个元素 subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125;// Stack 结构体遵从 Container 协议struct Stack&lt;Element&gt;: Container &#123; // Stack&lt;Element&gt; 的原始实现部分 var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // Container 协议的实现部分 mutating func append(_ item: Element) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125;var tos = Stack&lt;String&gt;()tos.push(\"google\")tos.push(\"runoob\")tos.push(\"taobao\")// 元素列表print(tos.items)// 元素个数print( tos.count) Where 语句类型约束能够确保类型符合泛型函数或类的定义约束。 你可以在参数列表中通过where语句定义参数的约束。 实例下面的例子定义了一个名为allItemsMatch的泛型函数，用来检查两个Container实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，反之则返回 false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Container 协议protocol Container &#123; associatedtype ItemType // 添加一个新元素到容器里 mutating func append(_ item: ItemType) // 获取容器中元素的数 var count: Int &#123; get &#125; // 通过索引值类型为 Int 的下标检索到容器中的每一个元素 subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125; // // 遵循Container协议的泛型TOS类型struct Stack&lt;Element&gt;: Container &#123; // Stack&lt;Element&gt; 的原始实现部分 var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // Container 协议的实现部分 mutating func append(_ item: Element) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125;// 扩展，将 Array 当作 Container 来使用extension Array: Container &#123;&#125; func allItemsMatch&lt;C1: Container, C2: Container&gt; (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool where C1.ItemType == C2.ItemType, C1.ItemType: Equatable &#123; // 检查两个容器含有相同数量的元素 if someContainer.count != anotherContainer.count &#123; return false &#125; // 检查每一对元素是否相等 for i in 0..&lt;someContainer.count &#123; if someContainer[i] != anotherContainer[i] &#123; return false &#125; &#125; // 所有元素都匹配，返回 true return true&#125;var tos = Stack&lt;String&gt;()tos.push(\"google\")tos.push(\"runoob\")tos.push(\"taobao\") var aos = [\"google\", \"runoob\", \"taobao\"] if allItemsMatch(tos, aos) &#123; print(\"匹配所有元素\")&#125; else &#123; print(\"元素不匹配\")&#125; //匹配所有元素"},{"title":"Swift笔记-协议","permalink":"http://zhouzhuo810.github.io/2017/06/07/Swift笔记-协议/","text":"协议规定了用来实现某一特定功能所必需的方法和属性。 语法123protocol SomeProtocol &#123; // 协议内容&#125; 要使类遵循某个协议，需要在类型名称后加上协议名称，中间以冒号:分隔，作为类型定义的一部分。遵循多个协议时，各协议之间用逗号,分隔。 123struct SomeStructure: FirstProtocol, AnotherProtocol &#123; // 结构体内容&#125; 如果类在遵循协议的同时拥有父类，应该将父类名放在协议名之前，以逗号分隔。 123class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123; // 类的内容&#125; 对属性的规定 协议用于指定特定的实例属性或类属性，而不用指定是存储型属性或计算型属性。此外还必须指明是只读的还是可读可写的。 协议中的通常用var来声明变量属性，在类型声明后加上{ set get }来表示属性是可读可写的，只读属性则用{ get }来表示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344protocol classa &#123; var marks: Int &#123; get set &#125; var result: Bool &#123; get &#125; func attendance() -&gt; String func markssecured() -&gt; String &#125; protocol classb: classa &#123; var present: Bool &#123; get set &#125; var subject: String &#123; get set &#125; var stname: String &#123; get set &#125; &#125; class classc: classb &#123; var marks = 96 let result = true var present = false var subject = \"Swift 协议\" var stname = \"Protocols\" func attendance() -&gt; String &#123; return \"The \\(stname) has secured 99% attendance\" &#125; func markssecured() -&gt; String &#123; return \"\\(stname) has scored \\(marks)\" &#125;&#125; let studdet = classc()studdet.stname = \"Swift\"studdet.marks = 98studdet.markssecured() print(studdet.marks)print(studdet.result)print(studdet.present)print(studdet.subject)print(studdet.stname) 对 Mutating 方法的规定值类型(结构体，枚举)的实例方法中，将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值。 12345678910111213141516171819202122232425262728293031323334353637protocol daysofaweek &#123; mutating func show()&#125; enum days: daysofaweek &#123; case sun, mon, tue, wed, thurs, fri, sat mutating func show() &#123; switch self &#123; case .sun: self = .sun print(\"Sunday\") case .mon: self = .mon print(\"Monday\") case .tue: self = .tue print(\"Tuesday\") case .wed: self = .wed print(\"Wednesday\") case .thurs: self = .thurs print(\"Wednesday\") case .fri: self = .fri print(\"Wednesday\") case .sat: self = .sat print(\"Saturday\") default: print(\"NO Such Day\") &#125; &#125;&#125; var res = days.wedres.show() 协议构造器规定在类中的实现你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器或者便利构造器。在这两种情况下，你都必须给构造器实现标上”required”修饰符： 1234567891011121314class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // 构造器实现 &#125;&#125;protocol tcpprotocol &#123; init(aprot: Int)&#125;class tcpClass: tcpprotocol &#123; required init(aprot: Int) &#123; &#125;&#125; 使用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现。 如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示required和override修饰符： 12345678910111213141516171819202122232425262728protocol tcpprotocol &#123; init(no1: Int)&#125;class mainClass &#123; var no1: Int // 局部变量 init(no1: Int) &#123; self.no1 = no1 // 初始化 &#125;&#125;class subClass: mainClass, tcpprotocol &#123; var no2: Int init(no1: Int, no2 : Int) &#123; self.no2 = no2 super.init(no1:no1) &#125; // 因为遵循协议，需要加上\"required\"; 因为继承自父类，需要加上\"override\" required override convenience init(no1: Int) &#123; self.init(no1:no1, no2:0) &#125;&#125;let res = mainClass(no1: 20)let show = subClass(no1: 30, no2: 50)print(\"res is: \\(res.no1)\")print(\"res is: \\(show.no1)\")print(\"res is: \\(show.no2)\") 协议类型尽管协议本身并不实现任何功能，但是协议可以被当做类型来使用。 协议可以像其他普通类型一样使用，使用场景: 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 在扩展中添加协议成员我们可以可以通过扩展来扩充已存在类型( 类，结构体，枚举等)。 扩展可以为已存在的类型添加属性，方法，下标脚本，协议等成员。 1234567891011121314151617181920212223242526272829303132333435363738protocol AgeClasificationProtocol &#123; var age: Int &#123; get &#125; func agetype() -&gt; String&#125;class Person &#123; let firstname: String let lastname: String var age: Int init(firstname: String, lastname: String) &#123; self.firstname = firstname self.lastname = lastname self.age = 10 &#125;&#125;extension Person : AgeClasificationProtocol &#123; func fullname() -&gt; String &#123; var c: String c = firstname + \" \" + lastname return c &#125; func agetype() -&gt; String &#123; switch age &#123; case 0...2: return \"Baby\" case 2...12: return \"Child\" case 13...19: return \"Teenager\" case let x where x &gt; 65: return \"Elderly\" default: return \"Normal\" &#125; &#125;&#125; 协议的继承协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的内容要求。 123protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // 协议定义&#125; 类专属协议123protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // 协议定义&#125; 协议合成Swift 支持合成多个协议，这在我们需要同时遵循多个协议时非常有用。 检验协议的一致性你可以使用is和as操作符来检查是否遵循某一协议或强制转化为某一类型。 is操作符用来检查实例是否遵循了某个协议。 as?返回一个可选值，当实例遵循协议时，返回该协议类型;否则返回nil。 as用以强制向下转型，如果强转失败，会引起运行时错误。 1234567891011121314151617181920212223242526272829303132333435363738protocol HasArea &#123; var area: Double &#123; get &#125;&#125;// 定义了Circle类，都遵循了HasArea协议class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;// 定义了Country类，都遵循了HasArea协议class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;// Animal是一个没有实现HasArea协议的类class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; // 对迭代出的每一个元素进行检查，看它是否遵循了HasArea协议 if let objectWithArea = object as? HasArea &#123; print(\"面积为 \\(objectWithArea.area)\") &#125; else &#123; print(\"没有面积\") &#125;&#125;"},{"title":"Swift笔记-扩展","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-扩展/","text":"扩展就是向一个已有的类、结构体或枚举类型添加新功能。扩展可以对一个类型添加新的功能，但是不能重写已有的功能。 Swift 中的扩展可以： 添加计算型属性和计算型静态属性 定义实例方法和类型方法 提供新的构造器 定义下标 定义和使用新的嵌套类型 使一个已有类型符合某个协议 语法扩展声明使用关键字 extension： 123extension SomeType &#123; // 加到SomeType的新功能写到这里&#125; 123extension SomeType: SomeProtocol, AnotherProctocol &#123; // 协议实现写到这里&#125; 计算型属性扩展可以向已有类型添加计算型实例属性和计算型类型属性。 123456789101112131415161718192021extension Int &#123; var add: Int &#123;return self + 100 &#125; var sub: Int &#123; return self - 10 &#125; var mul: Int &#123; return self * 10 &#125; var div: Int &#123; return self / 5 &#125;&#125; let addition = 3.addprint(\"加法运算后的值：\\(addition)\") let subtraction = 120.subprint(\"减法运算后的值：\\(subtraction)\") let multiplication = 39.mulprint(\"乘法运算后的值：\\(multiplication)\") let division = 55.divprint(\"除法运算后的值: \\(division)\") let mix = 30.add + 34.subprint(\"混合运算结果：\\(mix)\") 构造器扩展可以向已有类型添加新的构造器。 1234567891011121314151617181920212223242526struct sum &#123; var num1 = 100, num2 = 200&#125; struct diff &#123; var no1 = 200, no2 = 100&#125; struct mult &#123; var a = sum() var b = diff()&#125; extension mult &#123; init(x: sum, y: diff) &#123; _ = x.num1 + x.num2 _ = y.no1 + y.no2 &#125;&#125; let a = sum(num1: 100, num2: 200)let b = diff(no1: 200, no2: 100)let getMult = mult(x: a, y: b) print(\"getMult sum\\(getMult.a.num1, getMult.a.num2)\")print(\"getMult diff\\(getMult.b.no1, getMult.b.no2)\") 方法扩展可以向已有类型添加新的实例方法和类型方法。 123456789101112131415extension Int &#123; func topics(summation: () -&gt; ()) &#123; for _ in 0..&lt;self &#123; summation() &#125; &#125;&#125; 4.topics(&#123; print(\"扩展模块内\") &#125;) 3.topics(&#123; print(\"内型转换模块内\") &#125;) 这个topics方法使用了一个() -&gt; ()类型的单参数，表明函数没有参数而且没有返回值。 可变实例方法通过扩展添加的实例方法也可以修改该实例本身。 123456789101112131415161718extension Double &#123; mutating func square() &#123; let pi = 3.1415 self = pi * self * self &#125;&#125; var Trial1 = 3.3Trial1.square()print(\"圆的面积为: \\(Trial1)\") var Trial2 = 5.8Trial2.square()print(\"圆的面积为: \\(Trial2)\") var Trial3 = 120.3Trial3.square()print(\"圆的面积为: \\(Trial3)\") 下标扩展可以向一个已有类型添加新下标。 1234567891011121314extension Int &#123; subscript(var multtable: Int) -&gt; Int &#123; var no1 = 1 while multtable &gt; 0 &#123; no1 *= 10 --multtable &#125; return (self / no1) % 10 &#125;&#125; print(12[0]) //2print(7869[1]) //6print(786543[2]) //5 嵌套类型扩展可以向已有的类、结构体和枚举添加新的嵌套类型： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546extension Int &#123; enum calc &#123; case add case sub case mult case div case anything &#125; var print: calc &#123; switch self &#123; case 0: return .add case 1: return .sub case 2: return .mult case 3: return .div default: return .anything &#125; &#125;&#125; func result(numb: [Int]) &#123; for i in numb &#123; switch i.print &#123; case .add: print(\" 10 \") case .sub: print(\" 20 \") case .mult: print(\" 30 \") case .div: print(\" 40 \") default: print(\" 50 \") &#125; &#125;&#125; result([0, 1, 2, 3, 4, 7])"},{"title":"Swift笔记-类型转换","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-类型转换/","text":"Swift 中类型转换使用 is 和 as 操作符实现，is 用于检测值的类型，as 用于转换类型。 检查类型类型检查使用 is 关键字。 操作符 is 来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true，否则返回 false。 向下转型向下转型，用类型转换操作符(as? 或 as!) 当你不确定向下转型可以成功时，用类型转换的条件形式(as?)。条件形式的类型转换总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 nil。 只有你可以确定向下转型一定会成功时，才使用强制形式(as!)。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Subjects &#123; var physics: String init(physics: String) &#123; self.physics = physics &#125;&#125;class Chemistry: Subjects &#123; var equations: String init(physics: String, equations: String) &#123; self.equations = equations super.init(physics: physics) &#125;&#125;class Maths: Subjects &#123; var formulae: String init(physics: String, formulae: String) &#123; self.formulae = formulae super.init(physics: physics) &#125;&#125;let sa = [ Chemistry(physics: \"固体物理\", equations: \"赫兹\"), Maths(physics: \"流体动力学\", formulae: \"千兆赫\"), Chemistry(physics: \"热物理学\", equations: \"分贝\"), Maths(physics: \"天体物理学\", formulae: \"兆赫\"), Maths(physics: \"微分方程\", formulae: \"余弦级数\")]let samplechem = Chemistry(physics: \"固体物理\", equations: \"赫兹\")print(\"实例物理学是: \\(samplechem.physics)\")print(\"实例方程式: \\(samplechem.equations)\")let samplemaths = Maths(physics: \"流体动力学\", formulae: \"千兆赫\")print(\"实例物理学是: \\(samplemaths.physics)\")print(\"实例公式是: \\(samplemaths.formulae)\")var chemCount = 0var mathsCount = 0for item in sa &#123; // 类型转换的条件形式 if let show = item as? Chemistry &#123; print(\"化学主题是: '\\(show.physics)', \\(show.equations)\") // 强制形式 &#125; else if let example = item as? Maths &#123; print(\"数学主题是: '\\(example.physics)', \\(example.formulae)\") &#125;&#125; Any和AnyObject的类型转换Swift为不确定类型提供了两种特殊类型别名： AnyObject可以代表任何class类型的实例。 Any可以表示任何类型，包括方法类型（function types）。 Any 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Subjects &#123; var physics: String init(physics: String) &#123; self.physics = physics &#125;&#125;class Chemistry: Subjects &#123; var equations: String init(physics: String, equations: String) &#123; self.equations = equations super.init(physics: physics) &#125;&#125;class Maths: Subjects &#123; var formulae: String init(physics: String, formulae: String) &#123; self.formulae = formulae super.init(physics: physics) &#125;&#125;let sa = [ Chemistry(physics: \"固体物理\", equations: \"赫兹\"), Maths(physics: \"流体动力学\", formulae: \"千兆赫\"), Chemistry(physics: \"热物理学\", equations: \"分贝\"), Maths(physics: \"天体物理学\", formulae: \"兆赫\"), Maths(physics: \"微分方程\", formulae: \"余弦级数\")]let samplechem = Chemistry(physics: \"固体物理\", equations: \"赫兹\")print(\"实例物理学是: \\(samplechem.physics)\")print(\"实例方程式: \\(samplechem.equations)\")let samplemaths = Maths(physics: \"流体动力学\", formulae: \"千兆赫\")print(\"实例物理学是: \\(samplemaths.physics)\")print(\"实例公式是: \\(samplemaths.formulae)\")var chemCount = 0var mathsCount = 0for item in sa &#123; // 类型转换的条件形式 if let show = item as? Chemistry &#123; print(\"化学主题是: '\\(show.physics)', \\(show.equations)\") // 强制形式 &#125; else if let example = item as? Maths &#123; print(\"数学主题是: '\\(example.physics)', \\(example.formulae)\") &#125;&#125;// 可以存储Any类型的数组 exampleanyvar exampleany = [Any]()exampleany.append(12)exampleany.append(3.14159)exampleany.append(\"Any 实例\")exampleany.append(Chemistry(physics: \"固体物理\", equations: \"兆赫\"))for item2 in exampleany &#123; switch item2 &#123; case let someInt as Int: print(\"整型值为 \\(someInt)\") case let someDouble as Double where someDouble &gt; 0: print(\"Pi 值为 \\(someDouble)\") case let someString as String: print(\"\\(someString)\") case let phy as Chemistry: print(\"主题 '\\(phy.physics)', \\(phy.equations)\") default: print(\"None\") &#125;&#125; AnyObject 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Subjects &#123; var physics: String init(physics: String) &#123; self.physics = physics &#125;&#125;class Chemistry: Subjects &#123; var equations: String init(physics: String, equations: String) &#123; self.equations = equations super.init(physics: physics) &#125;&#125;class Maths: Subjects &#123; var formulae: String init(physics: String, formulae: String) &#123; self.formulae = formulae super.init(physics: physics) &#125;&#125;// [AnyObject] 类型的数组let saprint: [AnyObject] = [ Chemistry(physics: \"固体物理\", equations: \"赫兹\"), Maths(physics: \"流体动力学\", formulae: \"千兆赫\"), Chemistry(physics: \"热物理学\", equations: \"分贝\"), Maths(physics: \"天体物理学\", formulae: \"兆赫\"), Maths(physics: \"微分方程\", formulae: \"余弦级数\")]let samplechem = Chemistry(physics: \"固体物理\", equations: \"赫兹\")print(\"实例物理学是: \\(samplechem.physics)\")print(\"实例方程式: \\(samplechem.equations)\")let samplemaths = Maths(physics: \"流体动力学\", formulae: \"千兆赫\")print(\"实例物理学是: \\(samplemaths.physics)\")print(\"实例公式是: \\(samplemaths.formulae)\")var chemCount = 0var mathsCount = 0for item in saprint &#123; // 类型转换的条件形式 if let show = item as? Chemistry &#123; print(\"化学主题是: '\\(show.physics)', \\(show.equations)\") // 强制形式 &#125; else if let example = item as? Maths &#123; print(\"数学主题是: '\\(example.physics)', \\(example.formulae)\") &#125;&#125;var exampleany = [Any]()exampleany.append(12)exampleany.append(3.14159)exampleany.append(\"Any 实例\")exampleany.append(Chemistry(physics: \"固体物理\", equations: \"兆赫\"))for item2 in exampleany &#123; switch item2 &#123; case let someInt as Int: print(\"整型值为 \\(someInt)\") case let someDouble as Double where someDouble &gt; 0: print(\"Pi 值为 \\(someDouble)\") case let someString as String: print(\"\\(someString)\") case let phy as Chemistry: print(\"主题 '\\(phy.physics)', \\(phy.equations)\") default: print(\"None\") &#125;&#125; 在一个switch语句的case中使用强制形式的类型转换操作符（as, 而不是 as?）来检查和转换到一个明确的类型。"},{"title":"Swift笔记-自动引用计数","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-自动引用计数/","text":"Swift 使用自动引用计数（ARC）这一机制来跟踪和管理应用程序的内存通常情况下我们不需要去手动释放内存，因为 ARC 会在类的实例不再被使用时，自动释放其占用的内存。但在有些时候我们还是需要在代码中实现内存管理。 ARC 功能 当每次使用 init() 方法创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。 内存中会包含实例的类型信息，以及这个实例所有相关属性的值。 当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。 为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。 实例赋值给属性、常量或变量，它们都会创建此实例的强引用，只要强引用还在，实例是不允许被销毁的。 类实例之间的循环强引用这种情况发生在两个类实例互相保持对方的强引用，并让对方不被销毁。这就是所谓的循环强引用。 1234567891011121314151617181920212223242526272829303132class Person &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment? deinit &#123; print(\"\\(name) 被析构\") &#125;&#125;class Apartment &#123; let number: Int init(number: Int) &#123; self.number = number &#125; var tenant: Person? deinit &#123; print(\"Apartment #\\(number) 被析构\") &#125;&#125;// 两个变量都被初始化为nilvar runoob: Person?var number73: Apartment?// 赋值runoob = Person(name: \"Runoob\")number73 = Apartment(number: 73)// 意感叹号是用来展开和访问可选变量 runoob 和 number73 中的实例// 循环强引用被创建runoob!.apartment = number73number73!.tenant = runoob// 断开 runoob 和 number73 变量所持有的强引用时，引用计数并不会降为 0，实例也不会被 ARC 销毁// 注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。// 强引用循环阻止了Person和Apartment类实例的销毁，并在你的应用程序中造成了内存泄漏runoob = nilnumber73 = nil 解决实例之间的循环强引用Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题： 弱引用 无主引用 弱引用实例123456789101112131415161718192021222324252627class Module &#123; let name: String init(name: String) &#123; self.name = name &#125; var sub: SubModule? deinit &#123; print(\"\\(name) 主模块\") &#125;&#125;class SubModule &#123; let number: Int init(number: Int) &#123; self.number = number &#125; //weak修饰变量 weak var topic: Module? deinit &#123; print(\"子模块 topic 数为 \\(number)\") &#125;&#125;var toc: Module?var list: SubModule?toc = Module(name: \"ARC\")list = SubModule(number: 4)toc!.sub = listlist!.topic = toctoc = nillist = nil 无主引用实例123456789101112131415161718192021222324252627class Student &#123; let name: String var section: Marks? init(name: String) &#123; self.name = name &#125; deinit &#123; print(\"\\(name)\") &#125;&#125;class Marks &#123; let marks: Int //unowned修饰变量 unowned let stname: Student init(marks: Int, stname: Student) &#123; self.marks = marks self.stname = stname &#125; deinit &#123; print(\"学生的分数为 \\(marks)\") &#125;&#125;var module: Student?module = Student(name: \"ARC\")module!.section = Marks(marks: 98, stname: module!)module = nil 闭包引起的循环强引用12345678910111213141516171819202122232425262728class HTMLElement &#123; let name: String let text: String? lazy var asHTML: () -&gt; String = &#123; if let text = self.text &#123; //闭包强引用了self。 return \"&lt;\\(self.name)&gt;\\(text)&lt;/\\(self.name)&gt;\" &#125; else &#123; return \"&lt;\\(self.name) /&gt;\" &#125; &#125; init(name: String, text: String? = nil) &#123; self.name = name self.text = text &#125; deinit &#123; print(\"\\(name) is being deinitialized\") &#125; &#125;// 创建实例并打印信息var paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")print(paragraph!.asHTML()) 解决方法： 1234567891011121314151617181920212223242526272829303132333435class HTMLElement &#123; let name: String let text: String? lazy var asHTML: () -&gt; String = &#123; //这里 [unowned self] in if let text = self.text &#123; return \"&lt;\\(self.name)&gt;\\(text)&lt;/\\(self.name)&gt;\" &#125; else &#123; return \"&lt;\\(self.name) /&gt;\" &#125; &#125; init(name: String, text: String? = nil) &#123; self.name = name self.text = text &#125; deinit &#123; print(\"\\(name) 被析构\") &#125; &#125;//创建并打印HTMLElement实例var paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")print(paragraph!.asHTML())// HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息paragraph = nil//&lt;p&gt;hello, world&lt;/p&gt;//p 被析构"},{"title":"Swift笔记-可选链","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-可选链/","text":"！使用感叹号(!)可选链实例 1234567891011121314class Person &#123; var residence: Residence?&#125; class Residence &#123; var numberOfRooms = 1&#125; let john = Person() //将导致运行时错误let roomCount = john.residence!.numberOfRooms //fatal error: unexpectedly found nil while unwrapping an Optional value 想使用感叹号（!）强制解析获得这个人residence属性numberOfRooms属性值，将会引发运行时错误，因为这时没有可以供解析的residence值。 ？使用问号(?)可选链实例 123456789101112131415161718class Person &#123; var residence: Residence?&#125; class Residence &#123; var numberOfRooms = 1&#125; let john = Person() // 链接可选residence?属性，如果residence存在则取回numberOfRooms的值if let roomCount = john.residence?.numberOfRooms &#123; print(\"John 的房间号为 \\(roomCount)。\")&#125; else &#123; print(\"不能查看房间号\")&#125; //不能查看房间号 连接多层链接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person &#123; var residence: Residence?&#125; // 定义了一个变量 rooms，它被初始化为一个Room[]类型的空数组class Residence &#123; var rooms = [Room]() var numberOfRooms: Int &#123; return rooms.count &#125; subscript(i: Int) -&gt; Room &#123; return rooms[i] &#125; func printNumberOfRooms() &#123; print(\"房间号为 \\(numberOfRooms)\") &#125; var address: Address?&#125; // Room 定义一个name属性和一个设定room名的初始化器class Room &#123; let name: String init(name: String) &#123; self.name = name &#125;&#125; // 模型中的最终类叫做Addressclass Address &#123; var buildingName: String? var buildingNumber: String? var street: String? func buildingIdentifier() -&gt; String? &#123; if (buildingName != nil) &#123; return buildingName &#125; else if (buildingNumber != nil) &#123; return buildingNumber &#125; else &#123; return nil &#125; &#125;&#125; let john = Person() if let johnsStreet = john.residence?.address?.street &#123; print(\"John 的地址为 \\(johnsStreet).\")&#125; else &#123; print(\"不能检索地址\")&#125; //不能检索地址 对返回可选值的函数进行链接我们还可以通过可选链接来调用返回可空值的方法，并且可以继续对可选值进行链接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person &#123; var residence: Residence?&#125; // 定义了一个变量 rooms，它被初始化为一个Room[]类型的空数组class Residence &#123; var rooms = [Room]() var numberOfRooms: Int &#123; return rooms.count &#125; subscript(i: Int) -&gt; Room &#123; return rooms[i] &#125; func printNumberOfRooms() &#123; print(\"房间号为 \\(numberOfRooms)\") &#125; var address: Address?&#125; // Room 定义一个name属性和一个设定room名的初始化器class Room &#123; let name: String init(name: String) &#123; self.name = name &#125;&#125; // 模型中的最终类叫做Addressclass Address &#123; var buildingName: String? var buildingNumber: String? var street: String? func buildingIdentifier() -&gt; String? &#123; if (buildingName != nil) &#123; return buildingName &#125; else if (buildingNumber != nil) &#123; return buildingNumber &#125; else &#123; return nil &#125; &#125;&#125; let john = Person() if john.residence?.printNumberOfRooms() != nil &#123; print(\"指定了房间号)\")&#125; else &#123; print(\"未指定房间号\")&#125; //未指定房间号 上例中，对Residence的函数printNumberOfRooms进行链接。"},{"title":"Swift笔记-析构过程","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-析构过程/","text":"在一个类的实例被释放之前，析构函数被立即调用。 用关键字deinit来标示析构函数，类似于初始化函数用init来标示。析构函数只适用于类类型。 Swift 会自动释放不再需要的实例以释放资源。 Swift 通过自动引用计数（ARC）处理实例的内存管理。 通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。 实例1234567891011121314151617var counter = 0; // 引用计数器class BaseClass &#123; init() &#123; counter += 1; &#125; deinit &#123; counter -= 1; &#125;&#125;var show: BaseClass? = BaseClass()print(counter)show = nilprint(counter)//1//0"},{"title":"Swift笔记-继承","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-继承/","text":"在 Swift 中，类可以调用和访问超类的方法，属性和下标脚本，并且可以重写它们。 基类没有继承其它类的类，称之为基类（Base Class）。 123456789101112131415161718192021222324252627class StudDetails &#123; var stname: String! var mark1: Int! var mark2: Int! var mark3: Int! init(stname: String, mark1: Int, mark2: Int, mark3: Int) &#123; self.stname = stname self.mark1 = mark1 self.mark2 = mark2 self.mark3 = mark3 &#125;&#125;let stname = \"swift\"let mark1 = 98let mark2 = 89let mark3 = 76 let sds = StudDetails(stname:stname, mark1:mark1, mark2:mark2, mark3:mark3); print(sds.stname)print(sds.mark1)print(sds.mark2)print(sds.mark3)//swift//98//89//76 子类子类指的是在一个已有类的基础上创建一个新的类。 123class SomeClass: SomeSuperclass &#123; // 类的定义&#125; 实例1234567891011121314151617181920212223242526272829class StudDetails&#123; var mark1: Int; var mark2: Int; init(stm1:Int, results stm2:Int) &#123; mark1 = stm1; mark2 = stm2; &#125; func show() &#123; print(\"Mark1:\\(self.mark1), Mark2:\\(self.mark2)\") &#125;&#125;class Tom : StudDetails&#123; init() &#123; super.init(stm1: 93, results: 89) &#125;&#125; let tom = Tom()tom.show() //Mark1:93, Mark2:89 重写子类可以通过继承来的实例方法，类方法，实例属性，或下标脚本来实现自己的定制功能，我们把这种行为叫重写（overriding）。 重写 访问方法，属性，下标脚本 方法 super.somemethod() 属性 super.someProperty() 下标脚本 super[someIndex] 重写方法和属性重写方法1234567891011121314151617181920class SuperClass &#123; func show() &#123; print(\"这是超类 SuperClass\") &#125;&#125; class SubClass: SuperClass &#123; override func show() &#123; print(\"这是子类 SubClass\") &#125;&#125; let superClass = SuperClass()superClass.show() let subClass = SubClass()subClass.show() //这是超类 SuperClass//这是子类 SubClass 重写属性注意点： 如果你在重写属性中提供了 setter，那么你也一定要提供 getter。 如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。 123456789101112131415161718192021class Circle &#123; var radius = 12.5 var area: String &#123; return \"矩形半径 \\(radius) \" &#125;&#125; // 继承超类 Circleclass Rectangle: Circle &#123; var print = 7 override var area: String &#123; return super.area + \" ，但现在被重写为 \\(print)\" &#125;&#125; let rect = Rectangle()rect.radius = 25.0rect.print = 3print(\"Radius \\(rect.area)\") //Radius 矩形半径 25.0 ，但现在被重写为 3 写属性观察器12345678910111213141516171819202122232425262728293031323334class Circle &#123; var radius = 12.5 var area: String &#123; return \"矩形半径为 \\(radius) \" &#125;&#125; class Rectangle: Circle &#123; var print = 7 override var area: String &#123; return super.area + \" ，但现在被重写为 \\(print)\" &#125;&#125; let rect = Rectangle()rect.radius = 25.0rect.print = 3print(\"半径: \\(rect.area)\") class Square: Rectangle &#123; override var radius: Double &#123; //重写didSet didSet &#123; print = Int(radius/5.0)+1 &#125; &#125;&#125; let sq = Square()sq.radius = 100.0 print(\"半径: \\(sq.area)\") 防止重写我们可以使用 final 关键字防止它们被重写 123456final class Circle &#123; final var radius = 12.5 var area: String &#123; return \"矩形半径为 \\(radius) \" &#125;&#125;"},{"title":"Swift笔记-下标脚本","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-下标脚本/","text":"语法定义下标脚本使用subscript关键字，显式声明入参（一个或多个）和返回类型。 12345678subscript(index: Int) -&gt; Int &#123; get &#123; // 用于下标脚本值的声明 &#125; set(newValue) &#123; // 执行赋值操作 &#125;&#125; 123subscript(index: Int) -&gt; Int &#123; return index*4 // 用于下标脚本值的声明&#125; 实例123456789101112131415import Cocoastruct subexample &#123; let decrementer: Int subscript(index: Int) -&gt; Int &#123; return decrementer / index &#125;&#125;let division = subexample(decrementer: 100)print(\"100 除以 9 等于 \\(division[9])\")print(\"100 除以 2 等于 \\(division[2])\")print(\"100 除以 3 等于 \\(division[3])\")print(\"100 除以 5 等于 \\(division[5])\")print(\"100 除以 7 等于 \\(division[7])\") 实例21234567891011121314151617181920import Cocoaclass daysofaweek &#123; private var days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"saturday\"] subscript(index: Int) -&gt; String &#123; get &#123; return days[index] // 声明下标脚本的值 &#125; set(newValue) &#123; self.days[index] = newValue // 执行赋值操作 &#125; &#125;&#125;var p = daysofaweek()print(p[0])print(p[1])print(p[2])print(p[3]) 下标脚本选项 下标脚本允许任意数量的入参索引，并且每个入参类型也没有限制。 下标脚本的返回值也可以是任何类型。 下标脚本可以使用变量参数和可变参数。 123456789101112131415161718192021222324252627282930313233import Cocoastruct Matrix &#123; let rows: Int, columns: Int var print: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns print = Array(repeating: 0.0, count: rows * columns) &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; return print[(row * columns) + column] &#125; set &#123; print[(row * columns) + column] = newValue &#125; &#125;&#125;// 创建了一个新的 3 行 3 列的Matrix实例var mat = Matrix(rows: 3, columns: 3)// 通过下标脚本设置值mat[0,0] = 1.0mat[0,1] = 2.0mat[1,0] = 3.0mat[1,1] = 5.0// 通过下标脚本获取值print(\"\\(mat[0,0])\")print(\"\\(mat[0,1])\")print(\"\\(mat[1,0])\")print(\"\\(mat[1,1])\")"},{"title":"Swift笔记-方法","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-方法/","text":"实例方法在 Swift 语言中，实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供以下方法： 可以访问和修改实例属性 提供与实例目的相关的功能 实例方法要写在它所属的类型的前后大括号({})之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。 123456789101112131415161718192021222324252627import Cocoaclass Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func incrementBy(amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125;// 初始计数值是0let counter = Counter()// 计数值现在是1counter.increment()// 计数值现在是6counter.incrementBy(amount: 5)print(counter.count)// 计数值现在是0counter.reset()print(counter.count) 方法的局部参数名称和外部参数名称123456789101112131415import Cocoaclass multiplication &#123; var count: Int = 0 func incrementBy(first no1: Int, no2: Int) &#123; count = no1 * no2 print(count) &#125;&#125;let counter = multiplication()counter.incrementBy(first: 800, no2: 3)counter.incrementBy(first: 100, no2: 5)counter.incrementBy(first: 15000, no2: 3)//我们呢也可以使用下划线（_）设置第二个及后续的参数不提供一个外部名称。 self 属性类型的每一个实例都有一个隐含属性叫做self，self 完全等同于该实例本身。 1234567891011121314151617181920212223242526272829303132333435import Cocoaclass calculations &#123; let a: Int let b: Int let res: Int init(a: Int, b: Int) &#123; self.a = a self.b = b res = a + b print(\"Self 内: \\(res)\") &#125; func tot(c: Int) -&gt; Int &#123; return res - c &#125; func result() &#123; print(\"结果为: \\(tot(c: 20))\") print(\"结果为: \\(tot(c: 50))\") &#125;&#125;let pri = calculations(a: 600, b: 300)let sum = calculations(a: 1200, b: 300)pri.result()sum.result()//Self 内: 900//Self 内: 1500//结果为: 880//结果为: 850//结果为: 1480//结果为: 1450 在实例方法中修改值类型Swift 语言中结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改。 123456789101112131415161718192021222324import Cocoastruct area &#123; var length = 1 var breadth = 1 func area() -&gt; Int &#123; return length * breadth &#125; //使用mutating方法可以在实例中改变值类型的属性 mutating func scaleBy(res: Int) &#123; length *= res breadth *= res print(length) print(breadth) &#125;&#125;var val = area(length: 3, breadth: 5)val.scaleBy(res: 3)val.scaleBy(res: 30)val.scaleBy(res: 300) 类型方法类型本身调用的方法，这种方法就叫做类型方法。 声明结构体和枚举的类型方法，在方法的func关键字之前加上关键字static。类可能会用关键字class来允许子类重写父类的实现方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243mport Cocoa//类class Math&#123; //类型方法 class func abs(number: Int) -&gt; Int &#123; if number &lt; 0 &#123; return (-number) &#125; else &#123; return number &#125; &#125;&#125;//结构体struct absno&#123; //类型方法 static func abs(number: Int) -&gt; Int &#123; if number &lt; 0 &#123; return (-number) &#125; else &#123; return number &#125; &#125;&#125;let no = Math.abs(number: -35)let num = absno.abs(number: -5)print(no)print(num)//35//5"},{"title":"Swift笔记-属性","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-属性/","text":"存储属性12345678910111213import Cocoa struct Number&#123; var digits: Int let pi = 3.1415&#125; var n = Number(digits: 12345)n.digits = 67 print(\"\\(n.digits)\")print(\"\\(n.pi)\") 存储属性可以是变量存储属性（用关键字var定义），也可以是常量存储属性（用关键字let定义）。 可以在定义存储属性的时候指定默认值 也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值 123456789101112131415import Cocoa struct Number&#123; var digits: Int let pi = 3.1415&#125; var n = Number(digits: 12345)n.digits = 67 print(\"\\(n.digits)\")print(\"\\(n.pi)\")//67//3.1415 //构造方法给常量赋值12345678910111213141516171819import Cocoa struct Number&#123; var digits: Int let numbers: Double init(digits: Int, numbers : Double) &#123; self.digits = digits; self.numbers = numbers; &#125;&#125; var n = Number(digits: 12345, numbers: 3.14)n.digits = 67 print(\"\\(n.digits)\")print(\"\\(n.numbers)\")//67//3.14 延迟存储属性延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。 延迟存储属性一般用于： 延迟对象的创建。 当属性的值依赖于其他未知类 12345678910111213import Cocoa class sample &#123; lazy var no = number() // `var` 关键字是必须的&#125; class number &#123; var name = \"Runoob Swift 教程\"&#125; var firstsample = sample()print(firstsample.no.name)//Runoob Swift 教程 计算属性计算属性不直接存储值，而是提供一个 getter 来获取值，一个可选的 setter 来间接设置其他属性或变量的值。1234567891011121314151617181920212223242526import Cocoa class sample &#123; var no1 = 0.0, no2 = 0.0 var length = 300.0, breadth = 150.0 var middle: (Double, Double) &#123; get&#123; return (length / 2, breadth / 2) &#125; set(axis)&#123; no1 = axis.0 - (length / 2) no2 = axis.1 - (breadth / 2) &#125; &#125;&#125; var result = sample()print(result.middle)result.middle = (0.0, 10.0) print(result.no1)print(result.no2)//(150.0, 75.0)//-150.0//-65.0 只读计算属性只有 getter 没有 setter 的计算属性就是只读计算属性。12345678910111213141516171819202122import Cocoa class film &#123; var head = \"\" var duration = 0.0 var metaInfo: [String:String] &#123; return [ \"head\": self.head, \"duration\":\"\\(self.duration)\" ] &#125;&#125; var movie = film()movie.head = \"Swift 属性\"movie.duration = 3.09 print(movie.metaInfo[\"head\"]!)print(movie.metaInfo[\"duration\"]!) //Swift 属性//3.09 属性观察器属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外。 可以为属性添加如下的一个或全部观察器： willSet在设置新的值之前调用 didSet在新的值被设置之后立即调用 willSet和didSet观察器在属性初始化过程中不会被调用 123456789101112131415161718192021import Cocoa class Samplepgm &#123; var counter: Int = 0&#123; willSet(newTotal)&#123; print(\"计数器: \\(newTotal)\") &#125; didSet&#123; if counter &gt; oldValue &#123; print(\"新增数 \\(counter - oldValue)\") &#125; &#125; &#125;&#125;let NewCounter = Samplepgm()NewCounter.counter = 100NewCounter.counter = 800//计数器: 100//新增数 100//计数器: 800//新增数 700 类型属性类型属性是作为类型定义的一部分写在类型最外层的花括号（{}）内。 使用关键字 static 来定义值类型的类型属性，关键字 class 来为类定义类型属性。 12345678910111213141516171819struct Structname &#123; static var storedTypeProperty = \" \" static var computedTypeProperty: Int &#123; // 这里返回一个 Int 值 &#125;&#125; enum Enumname &#123; static var storedTypeProperty = \" \" static var computedTypeProperty: Int &#123; // 这里返回一个 Int 值 &#125;&#125; class Classname &#123; class var computedTypeProperty: Int &#123; // 这里返回一个 Int 值 &#125;&#125; 获取和设置类型属性的值类型属性是通过类型本身来获取和设置，而不是通过实例。 12345678910111213141516171819202122232425262728import Cocoa struct StudMarks &#123; static let markCount = 97 static var totalCount = 0 var InternalMarks: Int = 0 &#123; didSet &#123; if InternalMarks &gt; StudMarks.markCount &#123; InternalMarks = StudMarks.markCount &#125; if InternalMarks &gt; StudMarks.totalCount &#123; //类型属性赋值 StudMarks.totalCount = InternalMarks &#125; &#125; &#125;&#125; var stud1Mark1 = StudMarks()var stud1Mark2 = StudMarks() stud1Mark1.InternalMarks = 98print(stud1Mark1.InternalMarks) stud1Mark2.InternalMarks = 87print(stud1Mark2.InternalMarks)//97//87"},{"title":"Swift笔记-类","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-类/","text":"语法类定义12345class student &#123; var studname: String var mark: Int var mark2: Int&#125; 实例化类1let studrecord = student() 实例123456789101112131415import Cocoaclass MarksStruct &#123; var mark: Int init(mark: Int) &#123; self.mark = mark &#125;&#125;class studentMarks &#123; var mark = 300&#125;let marks = studentMarks()print(\"成绩为 \\(marks.mark)\")//成绩为 300 作为引用类型访问类属性类的属性可以通过 . 来访问。格式为：实例化类名.属性名： 123456789101112131415161718192021import Cocoaclass MarksStruct &#123; var mark: Int init(mark: Int) &#123; self.mark = mark &#125;&#125;class studentMarks &#123; var mark1 = 300 var mark2 = 400 var mark3 = 900&#125;let marks = studentMarks()print(\"Mark1 is \\(marks.mark1)\")print(\"Mark2 is \\(marks.mark2)\")print(\"Mark3 is \\(marks.mark3)\")//Mark1 is 300//Mark2 is 400//Mark3 is 900 恒等运算符 恒等运算符 不恒等运算符 运算符为：=== 运算符为：!== 如果两个常量或者变量引用同一个类实例则返回 true 如果两个常量或者变量引用不同一个类实例则返回 true 1234567891011121314151617181920212223import Cocoaclass SampleClass: Equatable &#123; let myProperty: String init(s: String) &#123; myProperty = s &#125;&#125;func ==(lhs: SampleClass, rhs: SampleClass) -&gt; Bool &#123; return lhs.myProperty == rhs.myProperty&#125;let spClass1 = SampleClass(s: \"Hello\")let spClass2 = SampleClass(s: \"Hello\")if spClass1 === spClass2 &#123;// false print(\"引用相同的类实例 \\(spClass1)\")&#125;if spClass1 !== spClass2 &#123;// true print(\"引用不相同的类实例 \\(spClass2)\")&#125;//引用不相同的类实例 SampleClass"},{"title":"Swift笔记-结构体","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-结构体/","text":"语法123456struct nameStruct &#123; Definition 1 Definition 2 …… Definition N&#125; 实例12345struct MarkStruct&#123; var mark1: Int var mark2: Int var mark3: Int&#125; 我们可以通过结构体名来访问结构体成员。结构体实例化使用 let 关键字： 1234567891011121314import Cocoastruct studentMarks &#123; var mark1 = 100 var mark2 = 78 var mark3 = 98&#125;let marks = studentMarks()print(\"Mark1 是 \\(marks.mark1)\")print(\"Mark2 是 \\(marks.mark2)\")print(\"Mark3 是 \\(marks.mark3)\")//Mark1 是 100//Mark2 是 78//Mark3 是 98 1234567891011121314import Cocoastruct MarksStruct &#123; var mark: Int init(mark: Int) &#123; self.mark = mark &#125;&#125;var aStruct = MarksStruct(mark: 98)var bStruct = aStruct // aStruct 和 bStruct 是使用相同值的结构体！bStruct.mark = 97print(aStruct.mark) // 98print(bStruct.mark) // 97 结构体应用当符合一条或多条以下条件时，请考虑构建结构体： 结构体的主要目的是用来封装少量相关简单数据值。 有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用。 任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。 结构体不需要去继承另一个已存在类型的属性或者行为。 结构体实例是通过值传递而不是通过引用传递。 123456789101112131415161718192021222324252627282930313233import Cocoastruct markStruct&#123; var mark1: Int var mark2: Int var mark3: Int init(mark1: Int, mark2: Int, mark3: Int)&#123; self.mark1 = mark1 self.mark2 = mark2 self.mark3 = mark3 &#125;&#125;print(\"优异成绩:\")var marks = markStruct(mark1: 98, mark2: 96, mark3:100)print(marks.mark1)print(marks.mark2)print(marks.mark3)print(\"糟糕成绩:\")var fail = markStruct(mark1: 34, mark2: 42, mark3: 13)print(fail.mark1)print(fail.mark2)print(fail.mark3)//优异成绩://98//96//100//糟糕成绩://34//42//13"},{"title":"Swift笔记-枚举","permalink":"http://zhouzhuo810.github.io/2017/06/06/Swift笔记-枚举/","text":"Swift 的枚举类似于 Objective C 和 C 的结构，枚举的功能为: 它声明在类中，可以通过实例化类来访问它的值。 枚举也可以定义构造函数（initializers）来提供一个初始成员值；可以在原始的实现基础上扩展它们的功能。 可以遵守协议（protocols）来提供标准的功能。 语法123enum enumname &#123; // 枚举定义放在这里&#125; 123456789101112131415161718192021222324252627282930313233import Cocoa// 定义枚举enum DaysofaWeek &#123; case Sunday case Monday case TUESDAY case WEDNESDAY case THURSDAY case FRIDAY case Saturday&#125;var weekDay = DaysofaWeek.THURSDAYweekDay = .THURSDAYswitch weekDay&#123;case .Sunday: print(\"星期天\")case .Monday: print(\"星期一\")case .TUESDAY: print(\"星期二\")case .WEDNESDAY: print(\"星期三\")case .THURSDAY: print(\"星期四\")case .FRIDAY: print(\"星期五\")case .Saturday: print(\"星期六\")&#125;//星期四 相关值123456789101112131415import Cocoaenum Student&#123; case Name(String) case Mark(Int,Int,Int)&#125;var studDetails = Student.Name(\"Runoob\")var studMarks = Student.Mark(98,97,95)switch studMarks &#123;case .Name(let studName): print(\"学生的名字是: \\(studName)。\")case .Mark(let Mark1, let Mark2, let Mark3): print(\"学生的成绩是: \\(Mark1),\\(Mark2),\\(Mark3)。\")&#125;//学生的成绩是: 98,97,95。 原始值 原始值可以是字符串，字符，或者任何整型值或浮点型值。 每个原始值在它的枚举声明中必须是唯一的。 当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个值没有被赋初值，将会被自动置为0。 123456789import Cocoaenum Month: Int &#123; case January = 1, February, March, April, May, June, July, August, September, October, November, December&#125;let yearMonth = Month.May.rawValueprint(\"数字月份为: \\(yearMonth)。\")//数字月份为: 5。"},{"title":"Swift笔记-闭包","permalink":"http://zhouzhuo810.github.io/2017/06/05/Swift笔记-闭包/","text":"sorted 方法排序闭包函数类型需为(String, String) -&gt; Bool。1234567891011import Cocoa let names = [\"AT\", \"AE\", \"D\", \"S\", \"BE\"] // 使用普通函数(或内嵌函数)提供排序功能,闭包函数类型需为(String, String) -&gt; Bool。func backwards(s1: String, s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversed = names.sorted(by: backwards) print(reversed) 闭包表达式语法123&#123; (parameters) -&gt; returnType in statements&#125; 下面的例子展示了之前backwards(::)函数对应的闭包表达式版本的代码：123var reverses = names.sorted(by: &#123; (s1 , s2) -&gt; Bool in return s1 &gt; s2&#125;) 根据上下文推断类型1reversed = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 单表达式闭包隐式返回1reversed = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) 在这个例子中，sort(_:)方法的第二个参数函数类型明确了闭包必须返回一个Bool类型值。因为闭包函数体只包含了一个单一表达式（s1 &gt; s2），该表达式返回Bool类型值，因此这里没有歧义，return关键字可以省略。 参数名称缩写Swift 自动为内联闭包提供了参数名称缩写功能，您可以直接通过$0，$1，$2来顺序调用闭包的参数，以此类推。 123456import Cocoa let names = [\"AT\", \"AE\", \"D\", \"S\", \"BE\"] var reversed = names.sorted( by: &#123; $0 &gt; $1 &#125; )print(reversed) 在这个例子中，$0和$1表示闭包中第一个和第二个String类型的参数。 运算符函数123456import Cocoa let names = [\"AT\", \"AE\", \"D\", \"S\", \"BE\"] var reversed = names.sorted(by: &gt;)print(reversed) 尾随闭包尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。12345678910111213func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; // 函数体部分&#125; // 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(&#123; // 闭包主体部分&#125;) // 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() &#123; // 闭包主体部分&#125; 如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把()省略掉：1234567import Cocoa let names = [\"AT\", \"AE\", \"D\", \"S\", \"BE\"] //尾随闭包var reversed = names.sorted() &#123; $0 &gt; $1 &#125;print(reversed) 注意： 如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把()省略掉。1reversed = names.sorted &#123; $0 &gt; $1 &#125;"},{"title":"Swift笔记-函数","permalink":"http://zhouzhuo810.github.io/2017/06/05/Swift笔记-函数/","text":"函数的定义与调用123456func sayHelloAgain(personName: String) -&gt; String &#123; return \"Hello again, \" + personName + \"!\"&#125; print(sayHelloAgain(personName: \"Anna\"))// prints \"Hello again, Anna!\" 函数参数与返回值无参函数12345func sayHelloWorld() -&gt; String &#123; return \"hello, world\"&#125;print(sayHelloWorld())// prints \"hello, world\" 多参数函数123456789func sayHello(personName: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return sayHelloAgain(personName: personName) &#125; else &#123; return sayHello(personName: personName, alreadyGreeted: &lt;#Bool#&gt;) &#125;&#125;print(sayHello(personName: \"Tim\", alreadyGreeted: true))// prints \"Hello again, Tim!\" 无返回值函数12345func sayGoodbye(personName: String) &#123; print(\"Goodbye, \\(personName)!\")&#125;sayGoodbye(personName: \"Dave\")// prints \"Goodbye, Dave!\" 多重返回值函数123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 可选元组返回类型为了安全地处理这个“空数组”问题，将minMax(_:)函数改写为使用可选元组返回类型，并且当数组为空时返回nil：12345678910111213func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 函数参数名称函数参数都有一个外部参数名（external parameter name）和一个局部参数名（local parameter name）。外部参数名用于在函数调用时标注传递给函数的参数，局部参数名在函数的实现内部使用。123456func someFunction(firstParameterName: Int, secondParameterName: Int) &#123; // function body goes here // firstParameterName and secondParameterName refer to // the argument values for the first and second parameters&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 指定外部参数名1234func someFunction(externalParameterName localParameterName: Int) &#123; // function body goes here, and can use localParameterName // to refer to the argument value for that parameter&#125; 12345func sayHello(to person: String, and anotherPerson: String) -&gt; String &#123; return \"Hello \\(person) and \\(anotherPerson)!\"&#125;print(sayHello(to: \"Bill\", and: \"Ted\"))// prints \"Hello Bill and Ted!\" 为每个参数指定外部参数名后，在你调用sayHello(to:and:)函数时两个外部参数名都必须写出来。 忽略外部参数名如果你不想为第二个及后续的参数设置外部参数名，用一个下划线（_）代替一个明确的参数名。123456func someFunction(firstParameterName: Int, _ secondParameterName: Int) &#123; // function body goes here // firstParameterName and secondParameterName refer to // the argument values for the first and second parameters&#125;someFunction(1, 2) 默认参数值你可以在函数体中为每个参数定义默认值（Deafult Values）。当默认值被定义后，调用这个函数时可以忽略这个参数。1234567func someFunction(_ parameterWithDefault: Int = 12) &#123; // function body goes here // if no arguments are passed to the function call, // value of parameterWithDefault is 12&#125;someFunction(6) // parameterWithDefault is 6someFunction() // parameterWithDefault is 12 可变参数1234567891011func arithmeticMean(numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3.0, which is the arithmetic mean of these five numbersarithmeticMean(3, 8.25, 18.75)// returns 10.0, which is the arithmetic mean of these three numbers 注意:一个函数最多只能有一个可变参数。 输入输出参数12345func swapTwoInts(a:inout Int, _ b:inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; 调用参数需要添加&amp; 12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")// prints \"someInt is now 107, and anotherInt is now 3\" 从上面这个例子中，我们可以看到 someInt 和 anotherInt 的原始值在 swapTwoInts(::) 函数中被修改，尽管它们的定义在函数体外。 函数类型每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成。 嵌套函数123456789101112131415161718func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backwards ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backwards: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 &#123; print(\"\\(currentValue)... \") currentValue = moveNearerToZero(currentValue)&#125;print(\"zero!\")// -4...// -3...// -2...// -1...// zero!"},{"title":"Swift笔记-控制流","permalink":"http://zhouzhuo810.github.io/2017/06/05/Swift笔记-控制流/","text":"For循环For-In你可以使用for-in循环来遍历一个集合里面的所有元素12345678for index in 1...5 &#123; print(\"\\(index) times 5 is \\(index * 5)\")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 如果你不需要知道区间序列内每一项的值，你可以使用下划线（_）替代变量名来忽略对值的访问： 12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print(\"\\(base) to the power of \\(power) is \\(answer)\")// 输出 \"3 to the power of 10 is 59049\" For123456for var index = 0; index &lt; 3; ++index &#123; print(\"index is \\(index)\")&#125;// index is 0// index is 1// index is 2 While循环 while循环，每次在循环开始时计算条件是否符合； repeat-while循环，每次在循环结束时计算条件是否符合。while循环，每次在循环开始时计算条件是否符合；repeat-while循环，每次在循环结束时计算条件是否符合。 While123while condition &#123; statements&#125; Repeat-While类似于java的do while 123repeat &#123; statements&#125; while condition 条件语句if12345var temperatureInFahrenheit = 30if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\")&#125;// 输出 \"It's very cold. Consider wearing a scarf.\" if else1234567temperatureInFahrenheit = 40if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\")&#125; else &#123; print(\"It's not that cold. Wear a t-shirt.\")&#125;// 输出 \"It's not that cold. Wear a t-shirt.\" if else if else123456789temperatureInFahrenheit = 90if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\")&#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(\"It's really warm. Don't forget to wear sunscreen.\")&#125; else &#123; print(\"It's not that cold. Wear a t-shirt.\")&#125;// 输出 \"It's really warm. Don't forget to wear sunscreen.\" if else if123456temperatureInFahrenheit = 72if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\")&#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(\"It's really warm. Don't forget to wear sunscreen.\")&#125; Switch12345678switch some value to consider &#123;case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else&#125; 1234567891011let someCharacter: Character = \"e\"switch someCharacter &#123;case \"a\", \"e\", \"i\", \"o\", \"u\": print(\"\\(someCharacter) is a vowel\")case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\": print(\"\\(someCharacter) is a consonant\")default: print(\"\\(someCharacter) is not a vowel or a consonant\")&#125;// 输出 \"e is a vowel\" 区间匹配12345678910111213141516171819let approximateCount = 62let countedThings = \"moons orbiting Saturn\"var naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = \"no\"case 1..&lt;5: naturalCount = \"a few\"case 5..&lt;12: naturalCount = \"several\"case 12..&lt;100: naturalCount = \"dozens of\"case 100..&lt;1000: naturalCount = \"hundreds of\"default: naturalCount = \"many\"&#125;print(\"There are \\(naturalCount) \\(countedThings).\")// 输出 \"There are dozens of moons orbiting Saturn.\" 元组1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print(\"(0, 0) is at the origin\")case (_, 0): print(\"(\\(somePoint.0), 0) is on the x-axis\")case (0, _): print(\"(0, \\(somePoint.1)) is on the y-axis\")case (-2...2, -2...2): print(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")default: print(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")&#125;// 输出 \"(1, 1) is inside the box\" 值绑定12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print(\"on the x-axis with an x value of \\(x)\")case (0, let y): print(\"on the y-axis with a y value of \\(y)\")case let (x, y): print(\"somewhere else at (\\(x), \\(y))\")&#125;// 输出 \"on the x-axis with an x value of 2\" Where12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print(\"(\\(x), \\(y)) is on the line x == y\")case let (x, y) where x == -y: print(\"(\\(x), \\(y)) is on the line x == -y\")case let (x, y): print(\"(\\(x), \\(y)) is just some arbitrary point\")&#125;// 输出 \"(1, -1) is on the line x == -y\" 控制转移语句Swift 有五种控制转移语句： continue break fallthrough return throw Continue123456789101112let puzzleInput = \"great minds think alike\"var puzzleOutput = \"\"for character in puzzleInput.characters &#123; switch character &#123; case \"a\", \"e\", \"i\", \"o\", \"u\", \" \": continue default: puzzleOutput.append(character) &#125;&#125;print(puzzleOutput)// 输出 \"grtmndsthnklk\" Breakbreak语句会立刻结束整个控制流的执行。 循环语句中的 break当在一个循环体中使用break时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号(})后的第一行代码。 Switch 语句中的 break当在一个switch代码块中使用break时，会立即中断该switch代码块的执行，并且跳转到表示switch代码块结束的大括号(})后的第一行代码。 fallthrough1234567891011let integerToDescribe = 5var description = \"The number \\(integerToDescribe) is\"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += \" a prime number, and also\" fallthroughdefault: description += \" an integer.\"&#125;print(description)// 输出 \"The number 5 is a prime number, and also an integer.\" return像if语句一样，guard的执行取决于一个表达式的布尔值。我们可以使用guard语句来要求条件必须为真时，以执行guard语句后的代码。不同于if语句，一个guard语句总是有一个else分句，如果条件不为真则执行else分句中的代码。12345678910111213141516171819202122232425262728293031func greet(person: [String: String]) &#123; guard let name = person[\"name\"] else &#123; return &#125; print(\"Hello \\(name)\") guard let location = person[\"location\"] else &#123; print(\"I hope the weather is nice near you.\") return &#125; print(\"I hope the weather is nice in \\(location).\")&#125; greet([\"name\": \"John\"])// prints \"Hello John!\"// prints \"I hope the weather is nice near you.\"greet([\"name\": \"Jane\", \"location\": \"Cupertino\"])// prints \"Hello Jane!\"// prints \"I hope the weather is nice in Cupertino.\"``` ## 检测 API 可用性 ```swiftif #available(iOS 9, OSX 10.10, *) &#123; // 在 iOS 使用 iOS 9 的 API, 在 OS X 使用 OS X v10.10 的 API&#125; else &#123; // 使用先前版本的 iOS 和 OS X 的 API&#125;"},{"title":"Swift笔记-集合类型","permalink":"http://zhouzhuo810.github.io/2017/06/05/Swift笔记-集合类型/","text":"Swift 语言提供Arrays、Sets和Dictionaries三种基本的集合类型用来存储集合数据。 数组创建一个空数组123var someInts = [Int]()print(\"someInts is of type [Int] with \\(someInts.count) items.\")// 打印 \"someInts is of type [Int] with 0 items.\" 创建一个带有默认值的数组12var threeDoubles = [Double](count: 3, repeatedValue:0.0)// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0] 通过两个数组相加创建一个数组12345var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 用字面量构造数组12var shoppingList: [String] = [\"Eggs\", \"Milk\"]// shoppingList 已经被构造并且拥有两个初始项。 或1var shoppingList = [\"Eggs\", \"Milk\"] 因为所有字面量中的值都是相同的类型，Swift 可以推断出[String]是shoppinglist中变量的正确类型。 访问和修改数组可以使用数组的只读属性count来获取数组中的数据项数量：12print(\"The shopping list contains \\(shoppingList.count) items.\")// 输出 \"The shopping list contains 2 items.\"（这个数组有2个项） 使用布尔值属性isEmpty作为检查count属性的值是否为 0 的捷径：123456if shoppingList.isEmpty &#123; print(\"The shopping list is empty.\")&#125; else &#123; print(\"The shopping list is not empty.\")&#125;// 打印 \"The shopping list is not empty.\"（shoppinglist 不是空的） 也可以使用append(_:)方法在数组后面添加新的数据项：12shoppingList.append(\"Flour\")// shoppingList 现在有3个数据项，有人在摊煎饼 使用加法赋值运算符（+=）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：1234shoppingList += [\"Baking Powder\"]// shoppingList 现在有四项了shoppingList += [\"Chocolate Spread\", \"Cheese\", \"Butter\"]// shoppingList 现在有七项了 可以直接使用下标语法来获取数组中的数据项 12var firstItem = shoppingList[0]// 第一项是 \"Eggs\" 还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把”Chocolate Spread”，”Cheese”，和”Butter”替换为”Bananas”和 “Apples”：12shoppingList[4...6] = [\"Bananas\", \"Apples\"]// shoppingList 现在有6项 调用数组的insert(_:atIndex:)方法来在某个具体索引值之前添加数据项：123shoppingList.insert(\"Maple Syrup\", atIndex: 0)// shoppingList 现在有7项// \"Maple Syrup\" 现在是这个列表中的第一项 类似的我们可以使用removeAtIndex(_:)方法来移除数组中的某一项。1234let mapleSyrup = shoppingList.removeAtIndex(0)// 索引值为0的数据项被移除// shoppingList 现在只有6项，而且不包括 Maple Syrup// mapleSyrup 常量的值等于被移除数据项的值 \"Maple Syrup\" 如果我们只想把数组中的最后一项移除，可以使用removeLast()方法1234let apples = shoppingList.removeLast()// 数组的最后一项被移除了// shoppingList 现在只有5项，不包括 cheese// apples 常量的值现在等于 \"Apples\" 字符串 数组的遍历我们可以使用for-in循环来遍历所有数组中的数据项：12345678for item in shoppingList &#123; print(item)&#125;// Six eggs// Milk// Flour// Baking Powder// Bananas 如果我们同时需要每个数据项的值和索引值，可以使用enumerate()方法来进行数组遍历。12345678for (index, value) in shoppingList.enumerate() &#123; print(\"Item \\(String(index + 1)): \\(value)\")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 集合创建和构造一个空的集合123var letters = Set&lt;Character&gt;()print(\"letters is of type Set&lt;Character&gt; with \\(letters.count) items.\")// 打印 \"letters is of type Set&lt;Character&gt; with 0 items.\" 用数组字面量创建集合12var favoriteGenres: Set&lt;String&gt; = [\"Rock\", \"Classical\", \"Hip hop\"]// favoriteGenres 被构造成含有三个初始值的集合 访问和修改一个集合为了找出一个Set中元素的数量，可以使用其只读属性count：12print(\"I have \\(favoriteGenres.count) favorite music genres.\")// 打印 \"I have 3 favorite music genres.\" 使用布尔属性isEmpty作为一个缩写形式去检查count属性是否为0：123456if favoriteGenres.isEmpty &#123; print(\"As far as music goes, I'm not picky.\")&#125; else &#123; print(\"I have particular music preferences.\")&#125;// 打印 \"I have particular music preferences.\" 你可以通过调用Set的insert(_:)方法来添加一个新元素：12favoriteGenres.insert(\"Jazz\")// favoriteGenres 现在包含4个元素 你可以通过调用Set的remove(_:)方法去删除一个元素，如果该值是该Set的一个元素则删除该元素并且返回被删除的元素值，否则如果该Set不包含该值，则返回nil123456if let removedGenre = favoriteGenres.remove(\"Rock\") &#123; print(\"\\(removedGenre)? I'm over it.\")&#125; else &#123; print(\"I never much cared for that.\")&#125;// 打印 \"Rock? I'm over it.\" 使用contains(_:)方法去检查Set中是否包含一个特定的值：123456if favoriteGenres.contains(\"Funk\") &#123; print(\"I get up on the good foot.\")&#125; else &#123; print(\"It's too funky in here.\")&#125;// 打印 \"It's too funky in here.\" 遍历一个集合123456for genre in favoriteGenres &#123; print(\"\\(genre)\")&#125;// Classical// Jazz// Hip hop 123456for genre in favoriteGenres.sort() &#123; print(\"\\(genre)\")&#125;// prints \"Classical\"// prints \"Hip hop\"// prints \"Jazz 基本集合操作 123456789101112let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sort()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.intersect(evenDigits).sort()// []oddDigits.subtract(singleDigitPrimeNumbers).sort()// [1, 9]oddDigits.exclusiveOr(singleDigitPrimeNumbers).sort()// [1, 2, 9] 字典创建一个空字典12var namesOfIntegers = [Int: String]()// namesOfIntegers 是一个空的 [Int: String] 字典 用字典字面量创建字典1var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;] 访问和修改字典我们可以通过字典的只读属性count来获取某个字典的数据项数量：12print(\"The dictionary of airports contains \\(airports.count) items.\")// 打印 \"The dictionary of airports contains 2 items.\"（这个字典有两个数据项） 使用布尔属性isEmpty来快捷地检查字典的count属性是否等于0：123456if airports.isEmpty &#123; print(\"The airports dictionary is empty.\")&#125; else &#123; print(\"The airports dictionary is not empty.\")&#125;// 打印 \"The airports dictionary is not empty.\" 我们还可以使用下标语法来通过给某个键的对应值赋值为nil来从字典里移除一个键值对：1234airports[\"APL\"] = \"Apple Internation\"// \"Apple Internation\" 不是真的 APL 机场, 删除它airports[\"APL\"] = nil// APL 现在被移除了 updateValue(_:forKey:)方法会返回对应值的类型的可选值。1234if let oldValue = airports.updateValue(\"Dublin Airport\", forKey: \"DUB\") &#123; print(\"The old value for DUB was \\(oldValue).\")&#125;// 输出 \"The old value for DUB was Dublin.\" removeValueForKey(_:)方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回nil：123456if let removedValue = airports.removeValueForKey(\"DUB\") &#123; print(\"The removed airport's name is \\(removedValue).\")&#125; else &#123; print(\"The airports dictionary does not contain a value for DUB.\")&#125;// prints \"The removed airport's name is Dublin Airport.\" 字典遍历12345for (airportCode, airportName) in airports &#123; print(\"\\(airportCode): \\(airportName)\")&#125;// YYZ: Toronto Pearson// LHR: London Heathrow 1234567891011for airportCode in airports.keys &#123; print(\"Airport code: \\(airportCode)\")&#125;// Airport code: YYZ// Airport code: LHRfor airportName in airports.values &#123; print(\"Airport name: \\(airportName)\")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow 如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受Array实例的 API 的参数，可以直接使用keys或者values属性构造一个新数组：12345let airportCodes = [String](airports.keys)// airportCodes 是 [\"YYZ\", \"LHR\"]let airportNames = [String](airports.values)// airportNames 是 [\"Toronto Pearson\", \"London Heathrow\"]"},{"title":"Swift笔记-字符串和字符","permalink":"http://zhouzhuo810.github.io/2017/06/05/Swift笔记-字符串和字符/","text":"初始化空字符串123var emptyString = \"\" // 空字符串字面量var anotherEmptyString = String() // 初始化方法// 两个字符串均为空并等价。 判断该字符串是否为空1234if emptyString.isEmpty &#123; print(\"Nothing to see here\")&#125;// 打印输出：\"Nothing to see here\" 字符串可变性1234567var variableString = \"Horse\"variableString += \" and carriage\"// variableString 现在为 \"Horse and carriage\"let constantString = \"Highlander\"constantString += \" and another Highlander\"// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。 使用字符遍历字符串中的字符12345678for character in \"Dog!🐶\".characters &#123; print(character)&#125;// D// o// g// !// 🐶 声明字符常量1let exclamationMark: Character = \"!\" 字符数组转字符串1234let catCharacters: [Character] = [\"C\", \"a\", \"t\", \"!\", \"🐱\"]let catString = String(catCharacters)print(catString)// 打印输出：\"Cat!🐱\" 连接字符串和字符+1234let string1 = \"hello\"let string2 = \" there\"var welcome = string1 + string2// welcome 现在等于 \"hello there\" +=123var instruction = \"look over\"instruction += string2// instruction 现在等于 \"look over there\" append()123let exclamationMark: Character = \"!\"welcome.append(exclamationMark)// welcome 现在等于 \"hello there!\" 字符串插值123let multiplier = 3let message = \"\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)\"// message is \"3 times 2.5 is 7.5\" 计算字符数量 (str.count)123var word = \"cafe\"print(\"the number of characters in \\(word) is \\(word.characters.count)\")// 打印输出 \"the number of characters in cafe is 4\" 访问和修改字符串字符串索引12345678910let greeting = \"Guten Tag!\"greeting[greeting.startIndex]// Ggreeting[greeting.endIndex.predecessor()]// !greeting[greeting.startIndex.successor()]// ulet index = greeting.startIndex.advancedBy(7)greeting[index]// a 1234for index in greeting.characters.indices &#123; print(\"\\(greeting[index]) \", terminator: \" \")&#125;// 打印输出 \"G u t e n T a g !\" 插入和删除()调用insert(_:atIndex:)方法可以在一个字符串的指定索引插入一个字符。123var welcome = \"hello\"welcome.insert(\"!\", atIndex: welcome.endIndex)// welcome now 现在等于 \"hello!\" 调用insertContentsOf(_:at:)方法可以在一个字符串的指定索引插入一个字符串。12welcome.insertContentsOf(\" there\".characters, at: welcome.endIndex.predecessor())// welcome 现在等于 \"hello there!\" 调用removeAtIndex(_:)方法可以在一个字符串的指定索引删除一个字符。12welcome.removeAtIndex(welcome.endIndex.predecessor())// welcome 现在等于 \"hello there\" 调用removeRange(_:)方法可以在一个字符串的指定索引删除一个子字符串。123let range = welcome.endIndex.advancedBy(-6)..&lt;welcome.endIndexwelcome.removeRange(range)// welcome 现在等于 \"hello\" 比较字符串字符串/字符相等 (== 和 !=)123456let quotation = \"We're a lot alike, you and I.\"let sameQuotation = \"We're a lot alike, you and I.\"if quotation == sameQuotation &#123; print(\"These two strings are considered equal\")&#125;// 打印输出 \"These two strings are considered equal\" 前缀/后缀相等通过调用字符串的hasPrefix(:)/hasSuffix(:)方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个String类型的参数，并返回一个布尔值。 12345678910111213let romeoAndJuliet = [ \"Act 1 Scene 1: Verona, A public place\", \"Act 1 Scene 2: Capulet's mansion\", \"Act 1 Scene 3: A room in Capulet's mansion\", \"Act 1 Scene 4: A street outside Capulet's mansion\", \"Act 1 Scene 5: The Great Hall in Capulet's mansion\", \"Act 2 Scene 1: Outside Capulet's mansion\", \"Act 2 Scene 2: Capulet's orchard\", \"Act 2 Scene 3: Outside Friar Lawrence's cell\", \"Act 2 Scene 4: A street in Verona\", \"Act 2 Scene 5: Capulet's mansion\", \"Act 2 Scene 6: Friar Lawrence's cell\"] 前缀判断12345678var act1SceneCount = 0for scene in romeoAndJuliet &#123; if scene.hasPrefix(\"Act 1 \") &#123; ++act1SceneCount &#125;&#125;print(\"There are \\(act1SceneCount) scenes in Act 1\")// 打印输出 \"There are 5 scenes in Act 1\" 后缀判断1234567891011var mansionCount = 0var cellCount = 0for scene in romeoAndJuliet &#123; if scene.hasSuffix(\"Capulet's mansion\") &#123; ++mansionCount &#125; else if scene.hasSuffix(\"Friar Lawrence's cell\") &#123; ++cellCount &#125;&#125;print(\"\\(mansionCount) mansion scenes; \\(cellCount) cell scenes\")// 打印输出 \"6 mansion scenes; 2 cell scenes\""},{"title":"Swift笔记-运算符","permalink":"http://zhouzhuo810.github.io/2017/06/05/Swift笔记-运算符/","text":"赋值运算符 (=)1234let b = 10var a = 5a = b// a 现在等于 10 算术运算符 加法（+） 减法（-） 乘法（*） 除法（/） 12341 + 2 // 等于 35 - 3 // 等于 22 * 3 // 等于 610.0 / 2.5 // 等于 4.0 加法运算符也可用于String的拼接： 1\"hello, \" + \"world\" // 等于 \"hello, world\" 求余运算符 (%)19 % 4 // 等于 1 18 % 2.5 // 等于 0.5 自增和自减 (++) (–) 当++前置的时候，先自増再返回。 当++后置的时候，先返回再自增。 123var a = 0let b = ++a // a 和 b 现在都是 1let c = a++ // a 现在 2, 但 c 是 a 自增前的值 1 一元负号运算符123let three = 3let minusThree = -three // minusThree 等于 -3let plusThree = -minusThree // plusThree 等于 3, 或 \"负负3\" 一元正号运算符一元正号（+）不做任何改变地返回操作数的值：12let minusSix = -6let alsoMinusSix = +minusSix // alsoMinusSix 等于 -6 组合赋值运算符表达式a += 2是a = a + 2的简写 12var a = 1a += 2 // a 现在是 3 比较运算符 等于（a == b） 不等于（a != b） 大于（a &gt; b） 小于（a &lt; b） 大于等于（a &gt;= b） 小于等于（a &lt;= b） 1234561 == 1 // true, 因为 1 等于 12 != 1 // true, 因为 2 不等于 12 &gt; 1 // true, 因为 2 大于 11 &lt; 2 // true, 因为 1 小于21 &gt;= 1 // true, 因为 1 大于等于 12 &lt;= 1 // false, 因为 2 并不小于等于 1 三目运算符 (a?b:c)问题 ? 答案1 : 答案2 如果问题成立，返回答案1的结果; 如果不成立，返回答案2的结果。 空合运算符 (a ?? b)空合运算符(a ?? b)将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b.这个运算符有两个条件: 表达式a必须是Optional可选类型 默认值b的类型必须要和a存储值的类型保持一致 12345let defaultColorName = \"red\"var userDefinedColorName: String? //默认值为 nilvar colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 \"red\" 123userDefinedColorName = \"green\"colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName 非空，因此 colorNameToUse 的值为 \"green\" 区间运算符闭区间运算符 （a…b）12345678for index in 1...5 &#123; print(\"\\(index) * 5 = \\(index * 5)\")&#125;// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20// 5 * 5 = 25 半开区间运算符 (a..&lt;b)123456789let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]let count = names.countfor i in 0..&lt;count &#123; print(\"第 \\(i + 1) 个人叫 \\(names[i])\")&#125;// 第 1 个人叫 Anna// 第 2 个人叫 Alex// 第 3 个人叫 Brian// 第 4 个人叫 Jack 逻辑运算逻辑非 (!a)12345let allowedEntry = falseif !allowedEntry &#123; print(\"ACCESS DENIED\")&#125;// 输出 \"ACCESS DENIED\" 逻辑与 (a &amp;&amp; b)12345678let enteredDoorCode = truelet passedRetinaScan = falseif enteredDoorCode &amp;&amp; passedRetinaScan &#123; print(\"Welcome!\")&#125; else &#123; print(\"ACCESS DENIED\")&#125;// 输出 \"ACCESS DENIED\" 逻辑或 (a || b)12345678let hasDoorKey = falselet knowsOverridePassword = trueif hasDoorKey || knowsOverridePassword &#123; print(\"Welcome!\")&#125; else &#123; print(\"ACCESS DENIED\")&#125;// 输出 \"Welcome!\" 使用括号来明确优先级123456if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123; print(\"Welcome!\")&#125; else &#123; print(\"ACCESS DENIED\")&#125;// 输出 \"Welcome!\""},{"title":"Swift笔记-基础部分","permalink":"http://zhouzhuo810.github.io/2017/06/02/Swift笔记-基础部分/","text":"常量和变量 变量 12345678910//变量声明var x = 1//声明多个变量var x = 1, y = 2//带类型声明var msg: String//变量赋值msg = \"Hello\" 常量 12//声明常量let pi = 3.14159 注释 单行注释 1//xxx 多行注释 1234/*xxxxxx*/ 基础数据类型 整数 （1）Int ：有符号整数 在32位平台上，Int和Int32长度相同。 在64位平台上，Int和Int64长度相同。 （2）UInt : 无符号整数 在32位平台上，UInt和UInt32长度相同。 在64位平台上，UInt和UInt64长度相同。 推荐使用Int，提高代码的可复用性。 浮点数 Double ： 64位浮点数Float ： 32位浮点数 注意：Double精确度很高，至少有15位数字，而Float最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。 布尔类型 Bool 123let a = truelet b = false 进制 一个十进制数，没有前缀 一个二进制数，前缀是0b 一个八进制数，前缀是0o 一个十六进制数，前缀是0x 1234let decimalInteger = 17 let binaryInteger = 0b10001 // 二进制的17 let octalInteger = 0o21 // 八进制的17 let hexadecimalInteger = 0x11 // 十六进制的17 如果一个十进制数的指数为exp，那这个数相当于基数和$10^{exp}$的乘积： 1.25e2 表示 $1.25 × 10^{2}$，等于 125.0。1.25e-2 表示 $1.25 × 10^{-2}$，等于 0.0125。 如果一个十六进制数的指数为exp，那这个数相当于基数和$2^{exp}$的乘积： 0xFp2 表示 $15 × 2^{2}$，等于 60.0。0xFp-2 表示 $15 × 2^{-2}$，等于 3.75。 类型转换 整数转换 12345// 下划线用来增加可读性，不会影响值let twoThousand: UInt16 = 2_000 let one: UInt8 = 1 // 将UInt8转换成UInt16再相加let twoThousandAndOne = twoThousand + UInt16(one) 浮点数转换 （1）整数-&gt;浮点数 12let three = 3let t = Double(three) （2）浮点数-&gt;整数 12let d = 0.123let i = Int(d) // i = 0 类型别名1typealias AudioSample = UInt16 元组元组（tuples）把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。 12let http404Error = (404, \"Not Found\") // http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") 你可以将一个元组的内容分解（decompose）成单独的常量和变量12345let (statusCode, statusMessage) = http404Error println(\"The status code is \\(statusCode)\") // 输出 \"The status code is 404\" println(\"The status message is \\(statusMessage)\") // 输出 \"The status message is Not Found\" 如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记123let (justTheStatusCode, _) = http404Error println(\"The status code is \\(justTheStatusCode)\") // 输出 \"The status code is 404\" 你还可以通过下标来访问元组中的单个元素，下标从零开始1234println(\"The status code is \\(http404Error.0)\") // 输出 \"The status code is 404\" println(\"The status message is \\(http404Error.1)\") // 输出 \"The status message is Not Found\" 你可以在定义元组的时候给单个元素命名12345let http200Status = (statusCode: 200, description: \"OK\") println(\"The status code is \\(http200Status.statusCode)\") // 输出 \"The status code is 200\" println(\"The status message is \\(http200Status.description)\") // 输出 \"The status message is OK\" 可选 （?）可选表示： 有值，等于 x 或者 没有值 “Int?”表示可选的Int 123let possibleNumber = \"123\" let convertedNumber = possibleNumber.toInt() // convertedNumber 被推测为类型 \"Int?\"， 或者类型 \"optional Int\" 判断可选是否有值123456if let actualNumber = possibleNumber.toInt() &#123; println(\"\\(possibleNumber) has an integer value of \\(actualNumber)\") &#125; else &#123; println(\"\\(possibleNumber) could not be converted to an integer\") &#125; // 输出 \"123 has an integer value of 123\" 隐式解析可选 （!）1234567let possibleString: String? = \"An optional string.\" println(possibleString!) // 需要惊叹号来获取值 // 输出 \"An optional string.\" let assumedString: String! = \"An implicitly unwrapped optional string.\" println(assumedString) // 不需要感叹号 // 输出 \"An implicitly unwrapped optional string.\" 注意：如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。 nil可以给可选变量赋值为nil来表示它没有值 1234var serverResponseCode: Int? = 404 // serverResponseCode 包含一个可选的 Int 值 404 serverResponseCode = nil // serverResponseCode 现在不包含值 如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为nil：12var surveyAnswer: String? // surveyAnswer 被自动设置为 nil 异常处理throws 抛出异常 try method 抓取并执行可能抛出异常的方法 do {try …} catch ErrorType {…处理} 处理异常 123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch Error.OutOfCleanDishes &#123; washDishes()&#125; catch Error.MissingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 断言 （assert）123let age = -3 assert(age &gt;= 0, \"A person's age cannot be less than zero\") // 因为 age &lt; 0，所以断言会触发 何时使用断言当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。 断言的适用情景： 整数的附属脚本索引被传入一个自定义附属脚本实现，但是下标索引值可能太小或者太大。 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。 一个可选值现在是nil，但是后面的代码运行需要一个非nil值。"},{"title":"使用hexo搭建github静态博客","permalink":"http://zhouzhuo810.github.io/2017/06/01/使用hexo搭建github静态博客/","text":"网上虽然不乏此类教程，但是实际操作起来还是遇到了一些问题。总结如下。 以Windows 7系统为例： 登陆Github，创建Reposity 用户名.github.io, 例如我的是zhouzhuo810.github.io 点击Setting-&gt;Choose Theme-&gt;随便选一个Theme-&gt;Select-&gt;默认Readme 访问username.github.io可以看到readme的内容即可。 安装Node.jshttps://nodejs.org/en/选择第二个下载安装。 安装git安装hexo使用cmd命令行工具， 123456F:npm install hexo-cli -ghexo init blogcd blognpm installhexo server 配置config123456title: 标题subtitle: 副标题description: 描述author: 作者language: zh-CN timezone: Asia/Shanghai 1234deploy: type: git repo: 复制github的ssh格式的路径(不要用https格式的) branch: master 配置ssh key。 打开git bash123$ git config --global user.name &quot;你的github用户名&quot;$ git config --global user.email &quot;你的github验证邮箱&quot;$ ssh-keygen -t rsa -C &quot;你的github验证邮箱&quot; 一路回车即可。 默认在C:\\Users\\xxx.ssh下 找到id_rsa.pub文件。 记事本打开，复制所有内容。 到https://github.com/settings/keys配置即可 标题随意。 最后别忘了最关键的一步： 验证SSH key配置是否成功： 1$ ssh -T git@github.com 如果弹出Are you sure you want to continue connecting (yes/no)?输入yes，回车 等待结果：如果返回以下内容，说明成功了。1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 然后在博客目录下，执行如下命令： 1npm install hexo-deployer-git --save 不行就1npm install --save hexo-deployer-git 发布123hexo ghexo d 查看不出意外的话，通过username.github.io可以访问到发布的内容了。 切换主题https://github.com/stkevintan/hexo-theme-material-flow 1.安装插件和下载主题 123456# change to work dircd /your_blog_dir/# install dependenciesnpm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content# download sourcegit clone https://github.com/stkevintan/hexo-theme-material-flow themes/material-flow 注意事项：多个插件同时安装报错时，拆分成单个插件安装即可。 如： 1234567npm i -S hexo-generator-searchnpm i -S hexo-generator-feed...... 2.修改配置文件_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657avatar: /images/avatar.jpgfavicon: /images/favicon.icotheme: material-flowsearch: path: search.xml field: postautoprefixer: exclude: - &apos;*.min.css&apos; # remove: false # prevent autoprefixer remove page-break-inside # browsers: # - &apos;last 2 versions&apos; # - &apos;&gt; 5%&apos;# Generator json contentjsonContent: meta: false keywords: false pages: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false posts: title: true slug: false date: false updated: false comments: false path: false link: false permalink: true excerpt: false keywords: false text: true raw: false content: false categories: false tags: falsefeed: type: atom path: atom.xml limit: 20 hub: content: 3.头像和网站图标配置 在sources文件夹下新建images文件夹即可。"}]}